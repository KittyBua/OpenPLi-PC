diff -ruN a/lib/gdi/picload.cpp b/lib/gdi/picload.cpp
--- a/lib/gdi/picload.cpp	2021-01-22 23:31:17.390493808 +0300
+++ b/lib/gdi/picload.cpp	2021-01-22 23:23:19.000000000 +0300
@@ -4,10 +4,9 @@
 
 #include <lib/base/cfile.h>
 #include <lib/gdi/picload.h>
+#include <lib/gdi/picexif.h>
 
 extern "C" {
-#define HAVE_BOOLEAN
-#define boolean int
 #include <jpeglib.h>
 #include <gif_lib.h>
 }
@@ -21,7 +20,79 @@
 	struct stat64 s;
 	if (stat64(file, &s) < 0)
 		return "";
-	return std::to_string((long)(s.st_size / 1024)) + " kB";
+	char tmp[20];
+	snprintf(tmp, 20, "%ld kB", (long)s.st_size / 1024);
+	return tmp;
+}
+
+static int convert_8Bit_to_24Bit(Cfilepara *filepara, unsigned char *dest)
+{
+	if( (!filepara) || (!dest))
+		return -1;
+
+	unsigned char *src = filepara->pic_buffer;
+	gRGB * palette     = filepara->palette;
+	int pixel_cnt      = filepara->ox * filepara->oy;
+
+	if( (!src) || (!palette) || (!pixel_cnt))
+		return -1;
+
+	for( int i = 0; i < pixel_cnt; i++)
+	{
+		*dest++ = palette[*src].r;
+		*dest++ = palette[*src].g;
+		*dest++ = palette[*src++].b;
+	}
+	return 0;
+}
+
+static unsigned char *simple_resize_24(unsigned char *orgin, int ox, int oy, int dx, int dy)
+{
+	unsigned char *cr = new unsigned char[dx * dy * 3];
+	if (cr == NULL)
+	{
+		eDebug("[Picload] Error malloc");
+		return orgin;
+	}
+	const int stride = 3 * dx;
+	#pragma omp parallel for
+	for (int j = 0; j < dy; ++j)
+	{
+		unsigned char* k = cr + (j * stride);
+		const unsigned char* p = orgin + (j * oy / dy * ox) * 3;
+		for (int i = 0; i < dx; i++)
+		{
+			const unsigned char* ip = p + (i * ox / dx) * 3;
+			*k++ = ip[0];
+			*k++ = ip[1];
+			*k++ = ip[2];
+		}
+	}
+	delete [] orgin;
+	return cr;
+}
+
+static unsigned char *simple_resize_8(unsigned char *orgin, int ox, int oy, int dx, int dy)
+{
+	unsigned char* cr = new unsigned char[dx * dy];
+	if (cr == NULL)
+	{
+		eDebug("[Picload] Error malloc");
+		return(orgin);
+	}
+	const int stride = dx;
+	#pragma omp parallel for
+	for (int j = 0; j < dy; ++j)
+	{
+		unsigned char* k = cr + (j * stride);
+		const unsigned char* p = orgin + (j * oy / dy * ox);
+		for (int i = 0; i < dx; i++)
+		{
+			*k++ = p[i * ox / dx];
+		}
+	}
+	delete [] orgin;
+	return cr;
 }
 
 static unsigned char *color_resize(unsigned char * orgin, int ox, int oy, int dx, int dy)
@@ -92,10 +163,7 @@
 	lseek(fd, BMP_COLOR_OFFSET, SEEK_SET);
 	for (int i = 0; i < count; i++)
 	{
-		if (read(fd, buff, 4) != 4) // failed to read rgb
-		{
-			break;
-		}
+		read(fd, buff, 4);
 		pallete[i].red = buff[2];
 		pallete[i].green = buff[1];
 		pallete[i].blue = buff[0];
@@ -110,39 +178,15 @@
 	int fd = open(file, O_RDONLY);
 	if (fd == -1) return NULL;
 	if (lseek(fd, BMP_SIZE_OFFSET, SEEK_SET) == -1) return NULL;
-	if (read(fd, buff, 4) != 4) // failed to read x
-	{
-		close(fd);
-		return NULL;
-	}
+	read(fd, buff, 4);
 	*x = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (read(fd, buff, 4) != 4) // failed to read y
-	{
-		close(fd);
-		return NULL;
-	}
+	read(fd, buff, 4);
 	*y = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (lseek(fd, BMP_TORASTER_OFFSET, SEEK_SET) == -1)
-	{
-		close(fd);
-		return NULL;
-	}
-	if (read(fd, buff, 4) != 4) // failed to read raster
-	{
-		close(fd);
-		return NULL;
-	}
+	if (lseek(fd, BMP_TORASTER_OFFSET, SEEK_SET) == -1) return NULL;
+	read(fd, buff, 4);
 	int raster = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (lseek(fd, BMP_BPP_OFFSET, SEEK_SET) == -1)
-	{
-		close(fd);
-		return NULL;
-	}
-	if (read(fd, buff, 2) != 2) // failed to read bpp
-	{
-		close(fd);
-		return NULL;
-	}
+	if (lseek(fd, BMP_BPP_OFFSET, SEEK_SET) == -1) return NULL;
+	read(fd, buff, 2);
 	int bpp = buff[0] + (buff[1] << 8);
 
 	unsigned char *pic_buffer = new unsigned char[(*x) * (*y) * 3];
@@ -160,10 +204,7 @@
 				return NULL;
 			for (int i = 0; i < *y; i++)
 			{
-				if (read(fd, tbuffer, (*x) / 2 + *x % 2) != ((*x) / 2 + *x % 2))
-				{
-					eDebug("[ePicLoad] failed to read %d bytes...", ((*x) / 2 + *x % 2));
-				}
+				read(fd, tbuffer, (*x) / 2 + *x % 2);
 				int j;
 				for (j = 0; j < (*x) / 2; j++)
 				{
@@ -184,12 +225,7 @@
 					*wr_buffer++ = pallete[c1].blue;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to read %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 6;
 			}
 			delete [] tbuffer;
@@ -205,10 +241,7 @@
 				return NULL;
 			for (int i = 0; i < *y; i++)
 			{
-				if (read(fd, tbuffer, *x) != *x)
-				{
-					eDebug("[ePicLoad] failed to read %d bytes...", *x);
-				}
+				read(fd, tbuffer, *x);
 				for (int j = 0; j < *x; j++)
 				{
 					wr_buffer[j * 3] = pallete[tbuffer[j]].red;
@@ -216,12 +249,7 @@
 					wr_buffer[j * 3 + 2] = pallete[tbuffer[j]].blue;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to skip %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 3;
 			}
 			delete [] tbuffer;
@@ -233,10 +261,7 @@
 			lseek(fd, raster, SEEK_SET);
 			for (int i = 0; i < (*y); i++)
 			{
-				if (read(fd, wr_buffer, (*x) * 3) != ((*x) * 3))
-				{
-					eDebug("[picload] failed to read %d bytes...", ((*x) * 3));
-				}
+				read(fd, wr_buffer, (*x) * 3);
 				for (int j = 0; j < (*x) * 3 ; j = j + 3)
 				{
 					unsigned char c = wr_buffer[j];
@@ -244,12 +269,7 @@
 					wr_buffer[j + 2] = c;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to skip %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 3;
 			}
 			break;
@@ -265,7 +285,7 @@
 
 //---------------------------------------------------------------------
 
-static void png_load(Cfilepara* filepara, int background, bool forceRGB=false)
+static void png_load(Cfilepara* filepara, unsigned int background)
 {
 	png_uint_32 width, height;
 	unsigned int i;
@@ -277,16 +297,21 @@
 
 	png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
 	if (png_ptr == NULL)
+	{
+		eDebug("[png_load] Error png_create_read_struct");
 		return;
+	}
 	png_infop info_ptr = png_create_info_struct(png_ptr);
 	if (info_ptr == NULL)
 	{
+		eDebug("[png_load] Error png_create_info_struct");
 		png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
 		return;
 	}
 
 	if (setjmp(png_jmpbuf(png_ptr)))
 	{
+		eDebug("[png_load] Error setjmp");
 		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 		return;
 	}
@@ -295,37 +320,44 @@
 
 	png_read_info(png_ptr, info_ptr);
 	png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_type, NULL, NULL);
+	int pixel_cnt = width * height;
 
-	if (!forceRGB && (color_type == PNG_COLOR_TYPE_GRAY || color_type & PNG_COLOR_MASK_PALETTE))
+	filepara->ox = width;
+	filepara->oy = height;
+
+	if( (bit_depth <= 8) && (color_type == PNG_COLOR_TYPE_GRAY || color_type & PNG_COLOR_MASK_PALETTE))
 	{
-		if (bit_depth < 8)
-		{
+		if(bit_depth < 8)
 			png_set_packing(png_ptr);
-			bit_depth = 8;
+
+		unsigned char *pic_buffer = new unsigned char[pixel_cnt];
+		if(!pic_buffer)
+		{
+			eDebug("[png_load] Error malloc");
+			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+			return;
 		}
-		unsigned char *pic_buffer = new unsigned char[height * width];
-		filepara->ox = width;
-		filepara->oy = height;
-		filepara->pic_buffer = pic_buffer;
-		filepara->bits = 8;
 
-		png_bytep *rowptr=new png_bytep[height];
-		for (unsigned int i=0; i!=height; i++)
+		int number_passes = png_set_interlace_handling(png_ptr);
+		png_read_update_info(png_ptr, info_ptr);
+
+		for(int pass = 0; pass < number_passes; pass++)
 		{
-			rowptr[i]=(png_byte*)pic_buffer;
-			pic_buffer += width;
+			fbptr = (png_byte *)pic_buffer;
+			for (i = 0; i < height; i++, fbptr += width)
+				png_read_row(png_ptr, fbptr, NULL);
 		}
-		png_read_rows(png_ptr, rowptr, 0, height);
-		delete [] rowptr;
 
 		if (png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE))
 		{
 			png_color *palette;
 			int num_palette;
 			png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+
 			filepara->palette_size = num_palette;
 			if (num_palette)
 				filepara->palette = new gRGB[num_palette];
+
 			for (int i=0; i<num_palette; i++)
 			{
 				filepara->palette[i].a=0;
@@ -341,52 +373,98 @@
 					filepara->palette[i].a=255-trans[i];
 			}
 		}
+		else
+		{
+			int c_cnt = 1 << bit_depth;
+			int c_step = (256 - 1)/(c_cnt-1);
+			filepara->palette_size = c_cnt;
+			filepara->palette = new gRGB[c_cnt];
+			for (int i=0; i < c_cnt; i++)
+			{
+				filepara->palette[i].a = 0;
+				filepara->palette[i].r = i * c_step;
+				filepara->palette[i].g = i * c_step;
+				filepara->palette[i].b = i * c_step;
+			}
+		}
+		filepara->pic_buffer = pic_buffer;
+		filepara->bits = 8;
+		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 	}
 	else
 	{
 		if (bit_depth == 16)
 			png_set_strip_16(png_ptr);
+
 		if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 			png_set_gray_to_rgb(png_ptr);
-		if (color_type & PNG_COLOR_MASK_PALETTE)
-			png_set_palette_to_rgb(png_ptr);
-		if (color_type & PNG_COLOR_MASK_ALPHA || png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
-		{
-			png_set_strip_alpha(png_ptr);
-			png_color_16 bg;
-			bg.red = (background >> 16) & 0xFF;
-			bg.green = (background >> 8) & 0xFF;
-			bg.blue = (background) & 0xFF;
-			bg.gray = bg.green;
-			bg.index = 0;
-			png_set_background(png_ptr, &bg, PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
-		}
+
+		if ((color_type == PNG_COLOR_TYPE_PALETTE)||(color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)||(png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))
+			png_set_expand(png_ptr);
+
+		int number_passes = png_set_interlace_handling(png_ptr);
 		png_read_update_info(png_ptr, info_ptr);
 
-		if (width * 3 != png_get_rowbytes(png_ptr, info_ptr))
+		int bpp =  png_get_rowbytes(png_ptr, info_ptr)/width;
+		if ((bpp != 4) && (bpp != 3))
 		{
 			eDebug("[ePicLoad] Error processing (did not get RGB data from PNG file)");
 			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 			return;
 		}
 
-		unsigned char *pic_buffer = new unsigned char[height * width * 3];
-		filepara->ox = width;
-		filepara->oy = height;
-		filepara->pic_buffer = pic_buffer;
+		unsigned char * pic_buffer = new unsigned char[pixel_cnt * bpp];
+		if(!pic_buffer)
+		{
+			eDebug("[png_load] Error malloc");
+			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+			return;
+		}
 
-		int number_passes = png_set_interlace_handling(png_ptr);
 		for(int pass = 0; pass < number_passes; pass++)
 		{
 			fbptr = (png_byte *)pic_buffer;
-			for (i = 0; i < height; i++, fbptr += width * 3)
+			for (int i = 0; i < height; i++, fbptr += width * bpp)
 				png_read_row(png_ptr, fbptr, NULL);
 		}
 		png_read_end(png_ptr, info_ptr);
+		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+
+		if (bpp == 4)
+		{
+			unsigned char * pic_buffer24 = new unsigned char[pixel_cnt * 3];
+			if(!pic_buffer24)
+			{
+				eDebug("[png_load] Error malloc");
+				delete [] pic_buffer;
+				return;
+			}
+
+			unsigned char *src = pic_buffer;
+			unsigned char *dst = pic_buffer24;
+			int a, r, g, b;
+			int bg_r = (background >> 16) & 0xFF;
+			int bg_g = (background >> 8) & 0xFF;
+			int bg_b = background & 0xFF;
+			for(int i = 0; i < pixel_cnt; i++)
+			{
+				r = (int)*src++;
+				g = (int)*src++;
+				b = (int)*src++;
+				a = (int)*src++;
+
+				*dst++ = ((r-bg_r)*a)/255 + bg_r;
+				*dst++ = ((g-bg_g)*a)/255 + bg_g;
+				*dst++ = ((b-bg_b)*a)/255 + bg_b;
+			}
+			delete [] pic_buffer;
+			filepara->pic_buffer = pic_buffer24;
+		}
+		else
+			filepara->pic_buffer = pic_buffer;
+		filepara->bits = 24;
 	}
-	png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 }
-
 //-------------------------------------------------------------------
 
 struct r_jpeg_error_mgr
@@ -408,11 +486,9 @@
 	struct jpeg_decompress_struct cinfo;
 	struct jpeg_decompress_struct *ciptr = &cinfo;
 	struct r_jpeg_error_mgr emgr;
-	unsigned char *pic_buffer;
+	unsigned char *pic_buffer=NULL;
 	CFile fh(file, "rb");
 
-	pic_buffer = nullptr;
-
 	if (!fh)
 		return NULL;
 
@@ -428,16 +504,18 @@
 	jpeg_stdio_src(ciptr, fh);
 	jpeg_read_header(ciptr, TRUE);
 	ciptr->out_color_space = JCS_RGB;
-
+	int s = 8;
 	if (max_x == 0) max_x = 1280; // sensible default
 	if (max_y == 0) max_y = 720;
-	// define scale to always fit vertically or horizontally in all orientations
-	ciptr->scale_denom = 8;
-	unsigned int screenmax = max_x > max_y ? max_x : max_y;
-	unsigned int imagemin  = ciptr->image_width < ciptr->image_height ? ciptr->image_width : ciptr->image_height;
-	ciptr->scale_num = (ciptr->scale_denom * screenmax + imagemin -1) / imagemin;
-	if (ciptr->scale_num < 1)  ciptr->scale_num = 1;
-	if (ciptr->scale_num > 16) ciptr->scale_num = 16;
+	while (s != 1)
+	{
+		if ((ciptr->image_width >= (s * max_x)) ||
+		    (ciptr->image_height >= (s * max_y)))
+			break;
+		s /= 2;
+	}
+	ciptr->scale_num = 1;
+	ciptr->scale_denom = s;
 
 	jpeg_start_decompress(ciptr);
 
@@ -517,10 +595,11 @@
 	}
 }
 
-static void gif_load(Cfilepara* filepara, bool forceRGB = false)
+static void gif_load(Cfilepara* filepara)
 {
 	unsigned char *pic_buffer = NULL;
 	int px, py, i, j;
+	unsigned char *fbptr;
 	unsigned char *slb=NULL;
 	GifFileType *gft;
 	GifRecordType rt;
@@ -529,10 +608,13 @@
 	int cmaps;
 	int extcode;
 
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	gft = DGifOpenFileName(filepara->file, &extcode);
-#else
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5)
 	gft = DGifOpenFileName(filepara->file);
+#else
+	{
+		int err;
+		gft = DGifOpenFileName(filepara->file, &err);
+	}
 #endif
 	if (gft == NULL)
 		return;
@@ -566,9 +648,10 @@
 						filepara->palette[i].b = cmap->Colors[i].Blue;
 					}
 
+					fbptr = pic_buffer;
 					if (!(gft->Image.Interlace))
 					{
-						for (i = 0; i < py; i++)
+						for (i = 0; i < py; i++, fbptr += px * 3)
 						{
 							if (DGifGetLine(gft, slb, px) == GIF_ERROR)
 								goto ERROR_R;
@@ -577,37 +660,17 @@
 					}
 					else
 					{
-						int IOffset[] = { 0, 4, 2, 1 }; // The way Interlaced image should.
-						int IJumps[] = { 8, 8, 4, 2 };  // be read - offsets and jumps...
 						for (j = 0; j < 4; j++)
 						{
-							for (i = IOffset[j]; i < py; i += IJumps[j])
+							slb = pic_buffer;
+							for (i = 0; i < py; i++)
 							{
-								if (DGifGetLine(gft, pic_buffer + i*px, px) == GIF_ERROR)
+								if (DGifGetLine(gft, slb, px) == GIF_ERROR)
 									goto ERROR_R;
+								slb += px;
 							}
 						}
 					}
-					if (forceRGB) {
-						unsigned char *pic_buffer2 = new unsigned char[px * py * 3];
-						if (pic_buffer2 != NULL) {
-							unsigned char *slb2 = pic_buffer2;
-							slb = pic_buffer;
-							for (j = 0; j < py; j++) {
-								for (i = 0; i < px; i++) {
-									int c = *slb++;
-									*slb2++ = filepara->palette[c].r;
-									*slb2++ = filepara->palette[c].g;
-									*slb2++ = filepara->palette[c].b;
-								}
-							}
-							filepara->bits = 24;
-							filepara->pic_buffer = pic_buffer2;
-							delete [] pic_buffer;
-							delete [] filepara->palette;
-							filepara->palette = NULL;
-						}
-					}
 				}
 				break;
 			case EXTENSION_RECORD_TYPE:
@@ -623,18 +686,24 @@
 	}
 	while (rt != TERMINATE_RECORD_TYPE);
 
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5) || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR == 0)
 	DGifCloseFile(gft);
+#else
+	{
+		int err;
+		DGifCloseFile(gft, &err);
+	}
 #endif
 	return;
 ERROR_R:
 	eDebug("[ePicLoad] <Error gif>");
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5) || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR == 0)
 	DGifCloseFile(gft);
+#else
+	{
+		int err;
+		DGifCloseFile(gft, &err);
+	}
 #endif
 }
 
@@ -642,7 +711,6 @@
 
 ePicLoad::ePicLoad():
 	m_filepara(NULL),
-	m_exif(NULL),
 	threadrunning(false),
 	m_conf(),
 	msg_thread(this,1),
@@ -659,7 +727,6 @@
 	background(0),
 	resizetype(1),
 	usecache(false),
-	auto_orientation(false),
 	thumbnailsize(180)
 {
 }
@@ -676,10 +743,6 @@
 		waitFinished();
 	if (m_filepara != NULL)
 		delete m_filepara;
-	if (m_exif != NULL) {
-		m_exif->ClearExif();
-		delete m_exif;
-	}
 }
 
 void ePicLoad::thread_finished()
@@ -691,27 +754,24 @@
 {
 	threadrunning = true;
 	hasStarted();
-	if (nice(4))
-	{
-		eDebug("[ePicLoad] thread failed to modify scheduling priority (%m)");
-	}
+	nice(4);
 	runLoop();
 }
 
 void ePicLoad::decodePic()
 {
-	getExif(m_filepara->file, m_filepara->id);
+	eDebug("[ePicLoad] decode picture... %s", m_filepara->file);
+
 	switch(m_filepara->id)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background);
-				break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);
-				break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);
-				break;
-		case F_GIF:	gif_load(m_filepara);
-				break;
+		case F_PNG:	png_load(m_filepara, m_conf.background); break;
+		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
+		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		case F_GIF:	gif_load(m_filepara); break;
 	}
+
+	if(m_filepara->pic_buffer != NULL)
+		resizePic();
 }
 
 void ePicLoad::decodeThumb()
@@ -723,48 +783,54 @@
 	std::string cachefile = "";
 	std::string cachedir = "/.Thumbnails";
 
-	getExif(m_filepara->file, m_filepara->id, 1);
-	if (m_exif && m_exif->m_exifinfo->IsExif)
+	if(m_filepara->id == F_JPEG)
 	{
-		if (m_exif->m_exifinfo->Thumnailstate == 2)
+		Cexif *exif = new Cexif;
+		if(exif->DecodeExif(m_filepara->file, 1))
 		{
-			free(m_filepara->file);
-			m_filepara->file = strdup(THUMBNAILTMPFILE);
-			m_filepara->id = F_JPEG; // imbedded thumbnail seem to be jpeg
-			exif_thumbnail = true;
-			eDebug("[ePicLoad] decodeThumb: Exif Thumbnail found");
-		}
-		//else
-		//	eDebug("[ePicLoad] decodeThumb: NO Exif Thumbnail found");
-		m_filepara->addExifInfo(m_exif->m_exifinfo->CameraMake);
-		m_filepara->addExifInfo(m_exif->m_exifinfo->CameraModel);
-		m_filepara->addExifInfo(m_exif->m_exifinfo->DateTime);
-		char buf[20];
-		snprintf(buf, 20, "%d x %d", m_exif->m_exifinfo->Width, m_exif->m_exifinfo->Height);
-		m_filepara->addExifInfo(buf);
+			if(exif->m_exifinfo->IsExif)
+			{
+				if(exif->m_exifinfo->Thumnailstate==2)
+				{
+					free(m_filepara->file);
+					m_filepara->file = strdup(THUMBNAILTMPFILE);
+					exif_thumbnail = true;
+					eDebug("[Picload] Exif Thumbnail found");
+				}
+				m_filepara->addExifInfo(exif->m_exifinfo->CameraMake);
+				m_filepara->addExifInfo(exif->m_exifinfo->CameraModel);
+				m_filepara->addExifInfo(exif->m_exifinfo->DateTime);
+				char buf[20];
+				snprintf(buf, 20, "%d x %d", exif->m_exifinfo->Width, exif->m_exifinfo->Height);
+				m_filepara->addExifInfo(buf);
+			}
+			exif->ClearExif();
+		}
+		delete exif;
 	}
-	else
-		eDebug("[ePicLoad] decodeThumb: NO Exif info");
 
-	if (!exif_thumbnail && m_conf.usecache)
+	if((! exif_thumbnail) && m_conf.usecache)
 	{
-		if (FILE *f = fopen(m_filepara->file, "rb"))
+		if(FILE *f=fopen(m_filepara->file, "rb"))
 		{
 			int c;
 			int count = 1024*100; // get checksum data out of max 100kB
-			uint32_t crc32 = 0;
+			unsigned long crc32 = 0;
 			char crcstr[9];
 			*crcstr = 0;
 
-			while (count-- > 0 && (c = getc(f)) != EOF)
+			while ((c=getc(f))!=EOF)
+			{
 				crc32 = crc32_table[((crc32) ^ (c)) & 0xFF] ^ ((crc32) >> 8);
+				if(--count < 0) break;
+			}
 
 			fclose(f);
 			crc32 = ~crc32;
-			sprintf(crcstr, "%08X", crc32);
+			sprintf(crcstr, "%08lX", crc32);
 
 			cachedir = m_filepara->file;
-			size_t pos = cachedir.find_last_of("/");
+			unsigned int pos = cachedir.find_last_of("/");
 			if (pos != std::string::npos)
 				cachedir = cachedir.substr(0, pos) + "/.Thumbnails";
 
@@ -782,16 +848,11 @@
 
 	switch (m_filepara->id)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background, true);
-				break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);
-				break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);
-				break;
-		case F_GIF:	gif_load(m_filepara, true);
-				break;
+		case F_PNG:	png_load(m_filepara, m_conf.background); break;
+		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
+		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		case F_GIF:	gif_load(m_filepara); break;
 	}
-	//eDebug("[ePicLoad] getThumb picture loaded %s", m_filepara->file);
 
 	if (exif_thumbnail)
 		::unlink(THUMBNAILTMPFILE);
@@ -817,17 +878,70 @@
 				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
 			}
 
-			// eDebug("[ePicLoad] getThumb resize from %dx%d to %dx%d", m_filepara->ox, m_filepara->oy, imx, imy);
-			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+			if (m_filepara->bits == 8)
+				m_filepara->pic_buffer = simple_resize_8(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+			else
+				m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+
 			m_filepara->ox = imx;
 			m_filepara->oy = imy;
 
-			if (jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
-				eDebug("[ePicLoad] getThumb: error saving cachefile");
+			if (m_filepara->bits == 8)
+			{
+				unsigned char * tmp = new unsigned char [m_filepara->ox * m_filepara->oy * 3];
+				if(tmp)
+				{
+					if(!convert_8Bit_to_24Bit(m_filepara, tmp))
+					{
+						if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, tmp))
+							eDebug("[Picload] error saving cachefile");
+					}
+					else
+						eDebug("[Picload] error saving cachefile");
+					delete [] tmp;
+				}
+				else
+					eDebug("[Picload] Error malloc");
+			}
+			else
+				if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
+					eDebug("[Picload] error saving cachefile");
 		}
+		resizePic();
 	}
 }
 
+void ePicLoad::resizePic()
+{
+	int imx, imy;
+
+	if (m_conf.aspect_ratio == 0)  // do not keep aspect ration but just fill the destination area
+	{
+		imx = m_filepara->max_x;
+		imy = m_filepara->max_y;
+	}
+	else if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+	{
+		imx = m_filepara->max_x;
+		imy = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+	}
+	else
+	{
+		imx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
+		imy = m_filepara->max_y;
+	}
+
+	if (m_filepara->bits == 8)
+		m_filepara->pic_buffer = simple_resize_8(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+	else if (m_conf.resizetype)
+		m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+	else
+		m_filepara->pic_buffer = simple_resize_24(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+
+	m_filepara->ox = imx;
+	m_filepara->oy = imy;
+}
+
 void ePicLoad::gotMessage(const Message &msg)
 {
 	switch (msg.type)
@@ -846,7 +960,7 @@
 			break;
 		case Message::decode_finished: // called from main thread
 			//eDebug("[ePicLoad] decode finished... %s", m_filepara->file);
-			if(m_filepara->callback)
+			if((m_filepara != NULL) && (m_filepara->callback))
 				PictureData(m_filepara->picinfo.c_str());
 			else
 			{
@@ -855,13 +969,11 @@
 					delete m_filepara;
 					m_filepara = NULL;
 				}
-				if (m_exif != NULL) {
-					m_exif->ClearExif();
-					delete m_exif;
-					m_exif = NULL;
-				}
 			}
 			break;
+		case Message::decode_error:
+			msg_main.send(Message(Message::decode_finished));
+			break;
 		default:
 			eDebug("[ePicLoad] unhandled thread message");
 	}
@@ -881,42 +993,77 @@
 		delete m_filepara;
 		m_filepara = NULL;
 	}
-	if (m_exif != NULL) {
-		m_exif->ClearExif();
-		delete m_exif;
-		m_exif = NULL;
-	}
 
-	int file_id = getFileType(file);
-	if(file_id < 0)
-	{
-		eDebug("[ePicLoad] <format not supported>");
-		return 1;
-	}
+	int file_id = -1;
+	unsigned char id[10];
+	int fd = ::open(file, O_RDONLY);
+	if (fd == -1) return -errno;
+	::read(fd, id, 10);
+	::close(fd);
+
+	if(id[1] == 'P' && id[2] == 'N' && id[3] == 'G')			file_id = F_PNG;
+	else if(id[6] == 'J' && id[7] == 'F' && id[8] == 'I' && id[9] == 'F')	file_id = F_JPEG;
+	else if(id[0] == 0xff && id[1] == 0xd8 && id[2] == 0xff)		file_id = F_JPEG;
+	else if(id[0] == 'B' && id[1] == 'M' )					file_id = F_BMP;
+	else if(id[0] == 'G' && id[1] == 'I' && id[2] == 'F')			file_id = F_GIF;
 
 	m_filepara = new Cfilepara(file, file_id, getSize(file));
 	m_filepara->max_x = x > 0 ? x : m_conf.max_x;
 	m_filepara->max_y = x > 0 ? y : m_conf.max_y;
 
-	if(m_filepara->max_x <= 0 || m_filepara->max_y <= 0)
+	if(file_id < 0 || m_filepara->max_x <= 0 || m_filepara->max_y <= 0)
 	{
+		if(file_id < 0)
+			eDebug("[Picload] <format not supported>");
+		else
+			eDebug("[Picload] <error in Para>");
+		if(async)
+		{
+			msg_thread.send(Message(Message::decode_error));
+			run();
+			return 0;
+		}
+
 		delete m_filepara;
 		m_filepara = NULL;
-		eDebug("[ePicLoad] <error in Para>");
-		return 1;
-	}
 
-	if (async) {
-		if(what == 1)
+		if(file_id < 0)
+			return 2;
+		else
+			return 3;
+	}
+	if(async)
+	{
+		if(what==1)
 			msg_thread.send(Message(Message::decode_Pic));
 		else
 			msg_thread.send(Message(Message::decode_Thumb));
 		run();
 	}
 	else if (what == 1)
+	{
 		decodePic();
+		if(!m_filepara->pic_buffer)
+		{
+		// in case of memeory leak, maybe we need this
+			delete m_filepara;
+			m_filepara = NULL;
+			eDebug("[Picload] <no data>");
+			return 4;
+		}
+	}
 	else
+	{
 		decodeThumb();
+		if(!m_filepara->pic_buffer)
+		{
+		//in case of memeory leak, maybe we need this
+			delete m_filepara;
+			m_filepara = NULL;
+			eDebug("[Picload] <no data>");
+			return 4;
+		}
+	}
 	return 0;
 }
 
@@ -934,66 +1081,65 @@
 {
 	ePyObject list;
 
-	// FIXME : m_filepara destroyed by getData. Need refactor this but plugins rely in it :(
-	getExif(filename, m_filepara ? m_filepara->id : -1);
-	if(m_exif && m_exif->m_exifinfo->IsExif)
-	{
-		char tmp[256];
-		int pos = 0;
-		list = PyList_New(23);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(filename));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Version));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->CameraMake));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->CameraModel));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->DateTime));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", m_exif->m_exifinfo->Width, m_exif->m_exifinfo->Height));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->FlashUsed));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Orientation));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Comments));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->MeteringMode));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->ExposureProgram));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->LightSource));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", m_exif->m_exifinfo->CompressionLevel));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", m_exif->m_exifinfo->ISOequivalent));
-		snprintf(tmp, sizeof(tmp) - 1, "%.2f", m_exif->m_exifinfo->Xresolution);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.2f", m_exif->m_exifinfo->Yresolution);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->ResolutionUnit));
-		snprintf(tmp, sizeof(tmp) - 1, "%.2f", m_exif->m_exifinfo->Brightness);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.5f sec.", m_exif->m_exifinfo->ExposureTime);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.5f", m_exif->m_exifinfo->ExposureBias);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.5f", m_exif->m_exifinfo->Distance);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.5f", m_exif->m_exifinfo->CCDWidth);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		snprintf(tmp, sizeof(tmp) - 1, "%.2f", m_exif->m_exifinfo->ApertureFNumber);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+	Cexif *exif = new Cexif;
+	if(exif->DecodeExif(filename))
+	{
+		if(exif->m_exifinfo->IsExif)
+		{
+			char tmp[256];
+			int pos=0;
+			list = PyList_New(23);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(filename));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif->m_exifinfo->Width, exif->m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif->m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif->m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif->m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(2);
+			PyList_SET_ITEM(list, 0, PyString_FromString(filename));
+			PyList_SET_ITEM(list, 1, PyString_FromString(exif->m_szLastError));
+		}
+		exif->ClearExif();
 	}
 	else
 	{
 		list = PyList_New(2);
 		PyList_SET_ITEM(list, 0, PyString_FromString(filename));
-		PyList_SET_ITEM(list, 1, PyString_FromString(m_exif->m_szLastError));
+		PyList_SET_ITEM(list, 1, PyString_FromString(exif->m_szLastError));
 	}
+	delete exif;
 
 	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
 }
 
-bool ePicLoad::getExif(const char *filename, int fileType, int Thumb)
-{
-	if (!m_exif) {
-		m_exif = new Cexif;
-		if (fileType < 0)
-			fileType = getFileType(filename);
-		return m_exif->DecodeExif(filename, Thumb, fileType);
-	}
-	return true;
-}
-
 int ePicLoad::getData(ePtr<gPixmap> &result)
 {
 	result = 0;
@@ -1006,283 +1152,151 @@
 	{
 		delete m_filepara;
 		m_filepara = NULL;
-		if (m_exif != NULL) {
-			m_exif->ClearExif();
-			delete m_exif;
-			m_exif = NULL;
-		}
 		return 0;
 	}
 
-	result = new gPixmap(m_filepara->max_x, m_filepara->max_y, m_filepara->bits == 8 ? 8 : 32,
-				NULL, m_filepara->bits == 8 ? gPixmap::accelAlways : gPixmap::accelAuto);
-	gUnmanagedSurface *surface = result->surface;
-
-	// original image    : ox, oy
-	// surface size      : max_x, max_y
-	// after aspect calc : scrx, scry
-	// center image      : xoff, yoff
-	int scrx, scry; // Aspect ratio calculation
-	int orientation = m_conf.auto_orientation ? (m_exif && m_exif->m_exifinfo->Orient ? m_exif->m_exifinfo->Orient : 1) : 1;
-	if ((m_conf.aspect_ratio > -0.1) && (m_conf.aspect_ratio < 0.1)) // do not keep aspect ratio but just fill the destination area
+	if (m_filepara->bits == 8)
 	{
-		scrx = m_filepara->max_x;
-		scry = m_filepara->max_y;
-	}
-	else if (orientation < 5) {
-		if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+		result=new gPixmap(eSize(m_filepara->max_x, m_filepara->max_y), 8, gPixmap::accelAlways);
+		gUnmanagedSurface *surface = result->surface;
+		surface->clut.data = m_filepara->palette;
+		surface->clut.colors = m_filepara->palette_size;
+		m_filepara->palette = NULL; // transfer ownership
+		int o_y=0, u_y=0, v_x=0, h_x=0;
+		int extra_stride = surface->stride - surface->x;
+
+		unsigned char *tmp_buffer=((unsigned char *)(surface->data));
+		unsigned char *origin = m_filepara->pic_buffer;
+
+		if(m_filepara->oy < m_filepara->max_y)
 		{
-			scrx = m_filepara->max_x;
-			scry = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+			o_y = (m_filepara->max_y - m_filepara->oy) / 2;
+			u_y = m_filepara->max_y - m_filepara->oy - o_y;
 		}
-		else
+		if(m_filepara->ox < m_filepara->max_x)
 		{
-			scrx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
-			scry = m_filepara->max_y;
+			v_x = (m_filepara->max_x - m_filepara->ox) / 2;
+			h_x = m_filepara->max_x - m_filepara->ox - v_x;
 		}
-	}
-	else {
-		if ((m_conf.aspect_ratio * m_filepara->ox * m_filepara->max_x / m_filepara->oy) <= m_filepara->max_y)
+
+		gColor background;
+		gRGB bg(m_conf.background);
+		background = surface->clut.findColor(bg);
+
+		if(m_filepara->oy < m_filepara->max_y)
 		{
-			scrx = m_filepara->max_x;
-			scry = (int)(m_conf.aspect_ratio * m_filepara->ox * m_filepara->max_x / m_filepara->oy);
+			memset(tmp_buffer, background, o_y * surface->stride);
+			tmp_buffer += o_y * surface->stride;
 		}
-		else
+
+		for(int a = m_filepara->oy; a > 0; --a)
 		{
-			scrx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->oy * m_filepara->max_y / m_filepara->ox);
-			scry = m_filepara->max_y;
+			if(m_filepara->ox < m_filepara->max_x)
+			{
+				memset(tmp_buffer, background, v_x);
+				tmp_buffer += v_x;
+			}
+
+			memcpy(tmp_buffer, origin, m_filepara->ox);
+			tmp_buffer += m_filepara->ox;
+			origin += m_filepara->ox;
+
+			if(m_filepara->ox < m_filepara->max_x)
+			{
+				memset(tmp_buffer, background, h_x);
+				tmp_buffer += h_x;
+			}
+
+			tmp_buffer += extra_stride;
+		}
+
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			memset(tmp_buffer, background, u_y * surface->stride);
 		}
 	}
-	float xscale = (float)(orientation < 5 ? m_filepara->ox : m_filepara->oy) / (float)scrx; // scale factor as result of screen and image size
-	float yscale = (float)(orientation < 5 ? m_filepara->oy : m_filepara->ox) / (float)scry;
-	int xoff = (m_filepara->max_x - scrx) / 2;  // borders as result of screen and image aspect
-	int yoff = (m_filepara->max_y - scry) / 2;
-	//eDebug("[getData] ox=%d oy=%d max_x=%d max_y=%d scrx=%d scry=%d xoff=%d yoff=%d xscale=%f yscale=%f aspect=%f bits=%d orientation=%d", m_filepara->ox, m_filepara->oy, m_filepara->max_x, m_filepara->max_y, scrx, scry, xoff, yoff, xscale, yscale, m_conf.aspect_ratio, m_filepara->bits, orientation);
-
-	unsigned char *tmp_buffer = ((unsigned char *)(surface->data));
-	unsigned char *origin = m_filepara->pic_buffer;
-	if (m_filepara->bits == 8) {
-		surface->clut.data = m_filepara->palette;
-		surface->clut.colors = m_filepara->palette_size;
-		m_filepara->palette = NULL; // transfer ownership
-	}
+	else
+	{
+		result=new gPixmap(eSize(m_filepara->max_x, m_filepara->max_y), 32, gPixmap::accelAuto);
+		gUnmanagedSurface *surface = result->surface;
+		int o_y=0, u_y=0, v_x=0, h_x=0;
+
+		unsigned char *tmp_buffer=((unsigned char *)(surface->data));
+		unsigned char *origin = m_filepara->pic_buffer;
+		int extra_stride = surface->stride - (surface->x * surface->bypp);
 
-	// fill borders with background color
-	if (xoff != 0 || yoff != 0) {
-		unsigned int background;
-		if (m_filepara->bits == 8) {
-			gRGB bg(m_conf.background);
-			background = surface->clut.findColor(bg);
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			o_y = (m_filepara->max_y - m_filepara->oy) / 2;
+			u_y = m_filepara->max_y - m_filepara->oy - o_y;
 		}
-		else {
-			background = m_conf.background;
+		if(m_filepara->ox < m_filepara->max_x)
+		{
+			v_x = (m_filepara->max_x - m_filepara->ox) / 2;
+			h_x = m_filepara->max_x - m_filepara->ox - v_x;
 		}
-		if (yoff != 0) {
-			if (m_filepara->bits == 8)
-			{
-				unsigned char* row_buffer;
-				row_buffer = (unsigned char *) tmp_buffer;
-				for (int x = 0; x < m_filepara->max_x; ++x) // fill first line
-					*row_buffer++ = background;
-			}
-			else
+
+		unsigned int background = m_conf.background;
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			for (int y = o_y; y != 0; --y)
 			{
-				unsigned int* row_buffer;
-				row_buffer = (unsigned int *) tmp_buffer;
-				for (int x = 0; x < m_filepara->max_x; ++x) // fill first line
+				int* row_buffer = (int*)tmp_buffer;
+				for (int x = m_filepara->ox; x !=0; --x)
 					*row_buffer++ = background;
+				tmp_buffer += surface->stride;
 			}
-			int y;
-			#pragma omp parallel for
-			for (y = 1; y < yoff; ++y) // copy from first line
-				memcpy(tmp_buffer + y*surface->stride, tmp_buffer,
-					m_filepara->max_x * surface->bypp);
-			#pragma omp parallel for
-			for (y = yoff + scry; y < m_filepara->max_y; ++y)
-				memcpy(tmp_buffer + y * surface->stride, tmp_buffer,
-					m_filepara->max_x * surface->bypp);
 		}
-		if (xoff != 0) {
-			if (m_filepara->bits == 8)
+
+		for(int a = m_filepara->oy; a > 0; --a)
+		{
+			if(m_filepara->ox < m_filepara->max_x)
 			{
-				unsigned char* row_buffer = (unsigned char *) (tmp_buffer + yoff * surface->stride);
-				int x;
-				for (x = 0; x < xoff; ++x) // fill left side of first line
-					*row_buffer++ = background;
-				row_buffer += scrx;
-				for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
-					*row_buffer++ = background;
-			}
-			else {
-				unsigned int* row_buffer = (unsigned int *) (tmp_buffer + yoff * surface->stride);
-				int x;
-				for (x = 0; x < xoff; ++x) // fill left side of first line
-					*row_buffer++ = background;
-				row_buffer += scrx;
-				for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
-					*row_buffer++ = background;
+				for(int b = v_x; b != 0; --b)
+				{
+					*(int*)tmp_buffer = background;
+					tmp_buffer += 4;
+				}
 			}
-			#pragma omp parallel for
-			for (int y = yoff + 1; y < scry; ++y) { // copy from first line
-				memcpy(tmp_buffer + y*surface->stride,
-					tmp_buffer + yoff * surface->stride,
-					xoff * surface->bypp);
-				memcpy(tmp_buffer + y*surface->stride + (xoff + scrx) * surface->bypp,
-					tmp_buffer + yoff * surface->stride + (xoff + scrx) * surface->bypp,
-					(m_filepara->max_x - scrx - xoff) * surface->bypp);
-			}
-		}
-		tmp_buffer += yoff * surface->stride + xoff * surface->bypp;
-	}
-
-	// Setup input image base pointers and x/y increment factors according to orientation
-	//     1        2       3      4         5            6           7          8
-	//
-	//   888888  888888      88  88      8888888888  88                  88  8888888888
-	//   88          88      88  88      88  88      88  88          88  88      88  88
-	//   8888      8888    8888  8888    88          8888888888  8888888888          88
-	//   88          88      88  88
-	//   88          88  888888  888888
-	//
-	// ori  ori-1   yfax    xfac    origin
-	// 0001 000      b * x   b      0
-	// 0010 001      b * x  -b                                    b * (x - 1)
-	// 0011 010     -b * x  -b      b * yscale * (sy - 1) * x  +  b * (x - 1)
-	// 0100 011     -b * x   b      b * yscale * (sy - 1) * x
-	// 0101 100      b       b * x  0
-	// 0110 101      b      -b * x                              b * (y - 1) * x
-	// 0111 110     -b      -b * x  b * yscale * (sy - 1)   +   b * (y - 1) * x
-	// 1000 111     -b       b * x  b * yscale * (sy - 1)
-	int bpp = m_filepara->bits / 8;
-#if 0
-	int iyfac = ((orientation-1) & 0x2) ? -bpp : bpp;
-	int ixfac = (orientation & 0x2) ? -bpp : bpp;
-	if (orientation < 5)
-		iyfac *= m_filepara->ox;
-	else
-		ixfac *= m_filepara->ox;
-	if (((orientation-1) & 0x6) == 2)
-		origin += bpp * (int)(yscale * (scry - 1)) * m_filepara->ox;
-	if (((orientation-1) & 0x6) == 6)
-		origin += bpp * (int)(yscale * (scry - 1));
-	if (((orientation) & 0x6) == 2)
-		origin += bpp * (m_filepara->ox - 1);
-	if (((orientation) & 0x6) == 6)
-		origin += bpp * (m_filepara->oy - 1) * m_filepara->ox;
-#else
-	int ixfac;
-	int iyfac;
-	if (orientation < 5) {
-		if (orientation == 1 || orientation == 2)
-			iyfac = bpp * m_filepara->ox; // run y across rows
-		else {
-			origin += bpp * (int)(yscale * (scry - 1)) * m_filepara->ox;
-			iyfac = -bpp * m_filepara->ox;
-		}
-		if (orientation == 2 || orientation == 3) {
-			origin += bpp * (m_filepara->ox - 1);
-			ixfac = -bpp;
-		}
-		else
-			ixfac = bpp;
-	}
-	else {
-		if (orientation == 5 || orientation == 6)
-			iyfac = bpp;
-		else {
-			origin += bpp * (int)(yscale * (scry - 1));
-			iyfac = -bpp ;
-		}
-		if (orientation == 6 || orientation == 7) {
-			origin += bpp * (m_filepara->oy - 1) * m_filepara->ox;
-			ixfac = -bpp * m_filepara->ox;
-		}
-		else
-			ixfac = bpp * m_filepara->ox;
-	}
-#endif
-	// Build output according to screen y by x loops
-	// Fill surface with image data, resize and correct for orientation on the fly
-	if (m_filepara->bits == 8)
-	{
-		#pragma omp parallel for
-		for (int y = 0; y < scry; ++y) {
-			const unsigned char *irow, *irowy = origin + iyfac * (int)(y * yscale);
-			unsigned char *srow = tmp_buffer + surface->stride * y;
-			float xind = 0.0;
-			for (int x = 0; x < scrx; ++x) {
-				irow = irowy + ixfac * (int)xind;
-				*srow++ = *irow;
-				xind += xscale;
+
+			for(int b = m_filepara->ox; b != 0; --b)
+			{
+				tmp_buffer[2] = *origin;
+				++origin;
+				tmp_buffer[1] = *origin;
+				++origin;
+				tmp_buffer[0] = *origin;
+				++origin;
+				tmp_buffer[3] = 0xFF; // alpha
+				tmp_buffer += 4;
 			}
-		}
-	}
-	else // 24-bit images
-	{
-		#pragma omp parallel for
-		for (int y = 0; y < scry; ++y) {
-			const unsigned char *irow, *irowy = origin + iyfac * (int)(yscale * y);
-			unsigned char *srow = tmp_buffer + surface->stride * y;
-			float xind = 0.0;
-
-			if (m_conf.resizetype != 1) {
-				// simple resizing
-				for (int x = 0; x < scrx; ++x) {
-					irow = irowy + ixfac * (int)xind;
-					srow[2] = irow[0];
-					srow[1] = irow[1];
-					srow[0] = irow[2];
-					srow[3] = 0xFF; // alpha
-					srow += 4;
-					xind += xscale;
+
+			if(m_filepara->ox < m_filepara->max_x)
+			{
+				for(int b = h_x; b != 0; --b)
+				{
+					*(int*)tmp_buffer = background;
+					tmp_buffer += 4;
 				}
 			}
-			else {
-				// color average resizing
-				// determine block range for resize
-				int yr = (int)((y+1) * yscale) - (int) (y * yscale);
-				if (y + yr >= scry)
-					yr = scry - y - 1;
-				for (int x = 0; x < scrx; x++) {
-					// determine x range for resize
-					int xr = (int)(xind + xscale) - (int) xind;
-					if (x + xr >= scrx)
-						xr = scrx - x - 1;
-					int r = 0;
-					int g = 0;
-					int b = 0;
-					int sq = 0;
-					irow = irowy + ixfac * (int)xind;
-					// average over all pixels in x by y block
-					for (int l = 0; l <= yr; l++) {
-						for (int k = 0; k <= xr; k++) {
-							r += irow[0];
-							g += irow[1];
-							b += irow[2];
-							sq++;
-							irow += ixfac;
-						}
-						irow -= (xr + 1) * ixfac; // go back to starting point of this subrow
-						irow += iyfac;
-					}
-					srow[2] = r / sq;
-					srow[1] = g / sq;
-					srow[0] = b / sq;
-					srow[3] = 0xFF; // alpha
-					srow += 4;
-					xind += xscale;
-				}
+
+			tmp_buffer += extra_stride;
+		}
+
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			for (int y = u_y; y != 0; --y)
+			{
+				int* row_buffer = (int*)tmp_buffer;
+				for (int x = m_filepara->ox; x !=0; --x)
+					*row_buffer++ = background;
+				tmp_buffer += surface->stride;
 			}
 		}
 	}
 
 	delete m_filepara; // so caller can start a new decode in background
 	m_filepara = NULL;
-	if (m_exif) {
-		m_exif->ClearExif();
-		delete m_exif;
-		m_exif = NULL;
-	}
 
 	return 0;
 }
@@ -1302,61 +1316,36 @@
 		bool useCache		= PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 4));
 		int resizeType	        = PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 5));
 		const char *bg_str	= PyString_AsString(PySequence_Fast_GET_ITEM(fast, 6));
-		bool auto_orientation	= (PySequence_Size(val) > 7) ?
-						PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 7)) :
-						0;
 
-		return setPara(width, height, aspectRatio, as, useCache, resizeType, bg_str, auto_orientation);
+		return setPara(width, height, aspectRatio, as, useCache, resizeType, bg_str);
 	}
 	return 1;
 }
 
-RESULT ePicLoad::setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str, bool auto_orientation)
+RESULT ePicLoad::setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str)
 {
 	m_conf.max_x = width;
 	m_conf.max_y = height;
 	m_conf.aspect_ratio = as == 0 ? 0.0 : aspectRatio / as;
 	m_conf.usecache	= useCache;
-	m_conf.auto_orientation	= auto_orientation;
 	m_conf.resizetype = resizeType;
 
 	if(bg_str[0] == '#' && strlen(bg_str)==9)
-		m_conf.background = strtoul(bg_str+1, NULL, 16) | 0xFF000000;
-	eDebug("[ePicLoad] setPara max-X=%d max-Y=%d aspect_ratio=%lf cache=%d resize=%d bg=#%08X auto_orient=%d",
+		m_conf.background = strtoul(bg_str+1, NULL, 16);
+	eDebug("[Picload] setPara max-X=%d max-Y=%d aspect_ratio=%lf cache=%d resize=%d bg=#%08X",
 			m_conf.max_x, m_conf.max_y, m_conf.aspect_ratio,
-			(int)m_conf.usecache, (int)m_conf.resizetype, m_conf.background, m_conf.auto_orientation);
+			(int)m_conf.usecache, (int)m_conf.resizetype, m_conf.background);
 	return 1;
 }
 
-int ePicLoad::getFileType(const char * file)
-{
-	unsigned char id[10];
-	int fd = ::open(file, O_RDONLY);
-	if (fd == -1)
-		return -1;
-	if (::read(fd, id, 10) != 10)
-	{
-		eDebug("[ePicLoad] getFileType failed to read magic num");
-		close(fd);
-		return -1;
-	}
-	::close(fd);
-
-	if      (id[1] == 'P'  && id[2] == 'N'  && id[3] == 'G')			return F_PNG;
-	else if (id[6] == 'J'  && id[7] == 'F'  && id[8] == 'I' && id[9] == 'F')	return F_JPEG;
-	else if (id[0] == 0xff && id[1] == 0xd8 && id[2] == 0xff)			return F_JPEG;
-	else if (id[0] == 'B'  && id[1] == 'M' )					return F_BMP;
-	else if (id[0] == 'G'  && id[1] == 'I'  && id[2] == 'F')			return F_GIF;
-	return -1;
-}
-
 //------------------------------------------------------------------------------------
 
 //for old plugins
-SWIG_VOID(int) loadPic(ePtr<gPixmap> &result, std::string filename, int x, int y, int aspect, int resize_mode, int rotate, int background, std::string cachefile)
+SWIG_VOID(int) loadPic(ePtr<gPixmap> &result, std::string filename, int x, int y, int aspect, int resize_mode, int rotate, unsigned int background, std::string cachefile)
 {
 	long asp1, asp2;
 	result = 0;
+	eDebug("[loadPic] deprecated loadPic function used!!! please use the non blocking version! you can see demo code in Pictureplayer plugin... this function is removed in the near future!");
 	ePicLoad mPL;
 
 	switch(aspect)
@@ -1386,3 +1375,4 @@
 
 	return 0;
 }
+
diff -ruN a/lib/gdi/picload.h b/lib/gdi/picload.h
--- a/lib/gdi/picload.h	2021-01-22 23:31:17.390493808 +0300
+++ b/lib/gdi/picload.h	2021-01-22 23:23:19.000000000 +0300
@@ -2,7 +2,6 @@
 #define __picload_h__
 
 #include <lib/gdi/gpixmap.h>
-#include <lib/gdi/picexif.h>
 #include <lib/base/thread.h>
 #include <lib/python/python.h>
 #include <lib/base/message.h>
@@ -31,6 +30,10 @@
 		palette_size(0),
 		bits(24),
 		id(mid),
+		max_x(0),
+		max_y(0),
+		ox(0),
+		oy(0),
 		picinfo(mfile),
 		callback(true)
 	{
@@ -39,8 +42,8 @@
 
 	~Cfilepara()
 	{
-		if (pic_buffer != NULL)	delete [] pic_buffer;
-		if (palette != NULL) delete [] palette;
+		if (pic_buffer != NULL)	delete pic_buffer;
+		if (palette != NULL) delete palette;
 		free(file);
 	}
 
@@ -52,11 +55,13 @@
 {
 	DECLARE_REF(ePicLoad);
 
+	enum{ F_PNG, F_JPEG, F_BMP, F_GIF};
+
 	void decodePic();
 	void decodeThumb();
+	void resizePic();
 
 	Cfilepara *m_filepara;
-	Cexif *m_exif;
 	bool threadrunning;
 
 	struct PConf
@@ -64,10 +69,9 @@
 		int max_x;
 		int max_y;
 		double aspect_ratio;
-		int background;
+		unsigned int background;
 		bool resizetype;
 		bool usecache;
-		bool auto_orientation;
 		int thumbnailsize;
 		int test;
 		PConf();
@@ -81,6 +85,7 @@
 			decode_Pic,
 			decode_Thumb,
 			decode_finished,
+			decode_error,
 			quit
 		};
 		Message(int type=0)
@@ -92,8 +97,6 @@
 	void thread();
 	int startThread(int what, const char *file, int x, int y, bool async=true);
 	void thread_finished();
-	bool getExif(const char *filename, int fileType=F_JPEG, int Thumb=0);
-	int getFileType(const char * file);
 public:
 	void waitFinished();
 	PSignal1<void, const char*> PictureData;
@@ -104,12 +107,12 @@
 	RESULT startDecode(const char *filename, int x=0, int y=0, bool async=true);
 	RESULT getThumbnail(const char *filename, int x=0, int y=0, bool async=true);
 	RESULT setPara(PyObject *val);
-	RESULT setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str, bool auto_orientation);
+	RESULT setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str);
 	PyObject *getInfo(const char *filename);
 	SWIG_VOID(int) getData(ePtr<gPixmap> &SWIG_OUTPUT);
 };
 
 //for old plugins
-SWIG_VOID(int) loadPic(ePtr<gPixmap> &SWIG_OUTPUT, std::string filename, int x, int y, int aspect, int resize_mode=0, int rotate=0, int background=0, std::string cachefile="");
+SWIG_VOID(int) loadPic(ePtr<gPixmap> &SWIG_OUTPUT, std::string filename, int x, int y, int aspect, int resize_mode=0, int rotate=0, unsigned int background=0, std::string cachefile="");
 
 #endif // __picload_h__
