diff -ruN o/configure.ac pc/configure.ac
--- o/configure.ac	2023-07-10 19:46:14.000000000 +0300
+++ pc/configure.ac	2024-07-21 14:42:55.837005519 +0300
@@ -1709,7 +1709,8 @@
 src/video_out/macosx/Makefile
 src/xine-utils/Makefile
 src/xine-engine/Makefile
-src/vdr/Makefile])
+src/vdr/Makefile
+src/e2pc/Makefile])
 AC_CONFIG_COMMANDS([default],[[chmod +x ./misc/SlackBuild ./misc/build_rpms.sh ./misc/relchk.sh]],[[]])
 AC_OUTPUT
 
diff -ruN o/debian/changelog pc/debian/changelog
--- o/debian/changelog	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/changelog	2024-07-21 15:30:04.844972765 +0300
@@ -1,42 +1,1339 @@
-xine-lib-1.2 (1.2.9+hg-0) experimental; urgency=low
+xine-lib-1.2 (1.2.13+release-1.2.13-e2pc) unstable; urgency=high
 
-  * Hg snapshot.
+  * Patched version for enigma2
+  * QA upload.
+  * debian/libxine2-misc-plugins.install: Also install plugins:
+
+ -- Boyuan Yang <byang@debian.org>  Wed, 23 Feb 2022 21:38:50 -0500
+
+xine-lib-1.2 (1.2.11-2) unstable; urgency=high
+
+  * QA upload.
+  * debian/libxine2-misc-plugins.install: Also install plugins:
+    + xineplug_decode_dav1d.so
+    + xineplug_decode_libaom.so
+    (Closes: #1006073)
+
+ -- Boyuan Yang <byang@debian.org>  Wed, 23 Feb 2022 21:38:50 -0500
+
+xine-lib-1.2 (1.2.11-1) unstable; urgency=medium
+
+  * QA upload.
+  * New upstream release 1.2.11.
+
+  [ Debian Janitor ]
+  * Remove constraints unnecessary since stretch.
+
+  [ Boyuan Yang ]
+  * debian/control: Bump Standards-Version to 4.6.0.
+  * debian/patches: Refresh patches.
+  * debian/patches/0001-Fix-ftbfs-with-gcc-10.patch,
+    debian/patches/0003-fix-non-Linux-build.patch: Dropped, merged upstream.
+  * debian/libxine2-misc-plugins.install.install:
+    Also install the newly-split xineplug_decode_to_spdif.so plugin.
+  * debian/libxine2-bin.lintian-overrides: Refresh lintian warning
+    override for "groff-message usr/share/man/man5/xine.5.gz" and
+    "symbols-declares-dependency-on-other-package libxine2".
+  * debian/changelog: Use correct email address for 1.0.1-1 changelog
+    entry (lintian error).
+  * debian/libxine2-bin.symbols: Add new symbols.
+
+ -- Boyuan Yang <byang@debian.org>  Tue, 05 Oct 2021 07:53:33 -0400
+
+xine-lib-1.2 (1.2.10-4) unstable; urgency=medium
+
+  * QA upload.
+  * Do install the xineplug_vo_gl_egl_x11 plugin on non-linux, and exclude
+    xineplug_vo_gl_egl_wl on all non-linux, not just hurd-i386.
+  * Drop dh_makeshlibs override, relying on the dh compat 12 default to keep
+    the -V option.
+  * Mark libxine2-dev as Multi-Arch:same.
+  * Remove now unused lintian override.
+
+ -- Mattia Rizzolo <mattia@debian.org>  Mon, 08 Jun 2020 19:32:30 +0200
+
+xine-lib-1.2 (1.2.10-3) unstable; urgency=medium
+
+  * QA upload.
+  * Add Breaks and Replaces closes: #961509
+  * Exclude more files from hurd-i386
+
+ -- Håvard Flaget Aasen <haavard_aasen@yahoo.no>  Wed, 03 Jun 2020 11:47:36 +0200
+
+xine-lib-1.2 (1.2.10-2) unstable; urgency=medium
+
+  * QA upload.
+  * Update year in d/copyright
+  * Bump debhelper to 13
+    - Remove override_dh_missing
+  * Remove xineplug_decode_qt.so from d/libxine2-misc-plugins.install
+  * Add 0003-fix-non-Linux-build.patch
+
+ -- Håvard Flaget Aasen <haavard_aasen@yahoo.no>  Sat, 23 May 2020 22:04:51 +0200
+
+xine-lib-1.2 (1.2.10-1) unstable; urgency=medium
+
+  * QA upload.
+  [ Ondřej Nový ]
+  * d/watch: Use https protocol
+
+  [ Håvard Flaget Aasen ]
+  * New upstream version
+  * Add 0001-Fix-ftbfs-with-gcc-10.patch closes: #957982
+  * Add 0002-Fix-spelling-error.patch
+  * Update Standards-Version to 4.5.0
+  * Change to debhelper-compat
+  * Remove override_dh_installchangelogs
+  * Update path to mime.types in d/not-installed
+  * debian/libxine2-bin.symbols:
+    - Add Build-Depends-Field
+    - Add new symbols for 1.2.10
+  * debian/control
+    - Bump debhelper to 12
+    - Use secure URI on homepage
+    - Remove obsolete *.doc package under Recommends
+    - Remove package from Suggested field, no longer in Debian
+    - Move libxine2-doc from Recommends to Suggests in d/control
+  * debian/*.install
+    - Update after joining 3 video plugins
+    - Add libpng decoder
+    - Add OpenGL, EGL and Wayland support
+  * Remove folder from d/libxine2-doc.docs
+  * Mark *-doc package as main-doc-package in d/rules
+  * Move xine.5 man-page to libxine2-bin
+
+ -- Håvard Flaget Aasen <haavard_aasen@yahoo.no>  Sun, 26 Apr 2020 17:28:13 +0200
+
+xine-lib-1.2 (1.2.9-1) unstable; urgency=medium
+
+  * QA upload.
+  * New upstream version.
+    - Fixes FTBFS with FFmpeg 4.0. (Closes: #888327)
+    - Fixes FTBFS on x32. (Closes: #883298)
 
- -- Darren Salt <devspam@moreofthesa.me.uk>  Wed, 27 Jun 2018 16:37:30 +0100
+  * debian/copyright:
+    - Update for 1.2.9.
+  * debian/control:
+    - Migrate Vcs to salsa.debian.org.
+    - Remove unused shlibs:{Recommends,Suggests} from libxine2-bin.
+    - Add missing perl:Depends to libxine2-dev.
+    - Bump standards version to 4.1.3.
+  * debian/libxine2-bin.symbols:
+    - Add new symbols for 1.2.9.
+  * debian/libxine2-misc-plugins.install:
+    - Merge network plugins into a single file.
+  * debian/not-installed:
+    - Update path to mime.types.
+
+ -- James Cowgill <jcowgill@debian.org>  Tue, 27 Mar 2018 00:48:56 +0100
+
+xine-lib-1.2 (1.2.8-2) unstable; urgency=medium
+
+  * QA upload.
+  * Upload to unstable.
+  * Update the libxine2-bin lintian override to match the last changes.
+
+ -- Mattia Rizzolo <mattia@debian.org>  Tue, 28 Nov 2017 11:32:02 +0100
+
+xine-lib-1.2 (1.2.8-1) experimental; urgency=medium
+
+  * QA upload.
+  * New upstream version 1.2.8.
+  * debian/copyright: rewrite using copyright-format 1.0 and greatly enlarge
+    with many missing attributions.  Closes: #532463
+  * Remove all patches, all applied upstream.
+  * Update symbols fom libxine2 1.2.8.
+  * debian/*.install:
+    + Update for the new release.
+    + Stop installing the obsoleted xine-config script.
+  * debian/control:
+    + Add new build-dependency on libdvdnav-dev.
+    + Make the description of libxine2-bin longer.
+    + Remove relentionship with very old package versions, now unneeded.
+    + Add a bunch of Multi-Arch:same markers.
+  * debian/rules:
+    + Force use of external libdvdnav.
+    + Bump shlibs version.
+  * Add lintian override for non-fixable manapge-has-errors-from-man.
+
+ -- Mattia Rizzolo <mattia@debian.org>  Wed, 22 Nov 2017 20:50:49 +0100
+
+xine-lib-1.2 (1.2.6-4) unstable; urgency=medium
+
+  * QA upload.
+  * Upload to unstable.
+  * debian/control:
+    + Mark libxine2-doc as Multi-Arch:foreign.
+    + Mark libxine2 as Multi-Arch:same.
+
+ -- Mattia Rizzolo <mattia@debian.org>  Mon, 13 Nov 2017 18:44:41 +0100
+
+xine-lib-1.2 (1.2.6-3) experimental; urgency=medium
+
+  * QA upload.
+  * Further restrict the installation of some plugins not available on
+    !linux-any.
+
+ -- Mattia Rizzolo <mattia@debian.org>  Sun, 12 Nov 2017 23:44:53 +0100
+
+xine-lib-1.2 (1.2.6-2) experimental; urgency=medium
+
+  * QA upload.
+  * debian/control:
+    + Orphan the package, see #881514.
+    + Set Vcs fields to a git repository in collab-maint.
+    + wrap-and-sort -ast.
+    + Change priority from extra (deprecated in policy 4.0.1) to optional.
+    + Appease lintian: s/meta-package/metapackage/.
+    + Bump Standards-Version to 4.1.1.
+    + Declare that xine-lib-1.2 doesn't need root to build: R³:no.
+  * debian/watch: fix the matching pattern.
+  * debian/rules:
+    + Use dh_lintian to install the lintian overrides.
+    + Convert the file to use the dh sequencer.
+    + Run dh_missing --fail-missing and add a debian/not-installed file.
+    + Enable hardening
+    + Drop special cases for MIPS and SPARC, to check if they are still needed.
+  * Add DEP-3 header to munmap.patch.
+  * Also install the inp_pvr plugin that is being built.
+  * Bump debhelper compat level to 10:
+    + Drop --with autoreconf, now default.
+    + Drop --parallel, now default.
+  * Use dh-exec to install some i386-specific plugins.
+  * Enable multiarch installation of the libraries.  Closes: #876026
+  * Disable the ESD and GnomeVFS plugins, as the related libraries are
+    deprecated.  Closes: #856093, #868407
+
+ -- Mattia Rizzolo <mattia@debian.org>  Sun, 12 Nov 2017 20:28:52 +0100
+
+xine-lib-1.2 (1.2.6-1.3) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * xcb.patch: New, from upstream, fix linking with new xcb versions.
+    (Closes: #839371)
+  * munmap.patch: New, correctly call munmap() on a previously mmap()ed
+    location.  (Closes: #773966)
+  * Drop -dbg package in favor of autogenerated -dbgsym packages.
+  * Use dpkg default compression.
+
+ -- Andreas Beckmann <anbe@debian.org>  Tue, 10 Jan 2017 18:43:36 +0100
+
+xine-lib-1.2 (1.2.6-1.2) unstable; urgency=medium
+
+  * Non-maintainer upload.
+
+  [ Santiago Vila ]
+  * Add build-arch and build-indep targets. (Closes: #822038)
+
+ -- Sebastian Ramacher <sramacher@debian.org>  Sun, 04 Sep 2016 11:49:58 +0200
+
+xine-lib-1.2 (1.2.6-1.1) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * Build without samba support on hurd-i386.  (Closes: #815354)
+  * Add support for FFmpeg 2.9, thanks to Andreas Cadhalpun.  (Closes: #803873)
+
+ -- Andreas Beckmann <anbe@debian.org>  Thu, 10 Mar 2016 14:43:17 +0100
+
+xine-lib-1.2 (1.2.6-1) unstable; urgency=medium
+
+  * New upstream release.
+    - Fixes FTBFS with libcaca 0.99 beta 19. (Closes: #749741)
+  * Don't depend on libva-dev on hurd-i386. (Closes: #748379)
+  * Simplify build dependency logic (convert to linux-any). (Ref. #748379)
+  * Tighten dependencies on libxine2-bin. (Closes: #743961, #743964)
+  * Policy compliance:
+    - bump standards version to 3.9.5
+    - remove DM-Upload-Allowed
+    - override lintian embedded library error (libmms): needs upstream work
+    - update symbols files; remove Debian revisions where appropriate
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Sun, 06 Jul 2014 17:16:49 +0100
+
+xine-lib-1.2 (1.2.5-1) unstable; urgency=medium
+
+  * New upstream release.
+    - Works with libav10. (Closes: #739458)
+    - Dropped patches since all are present upstream.
+    - libvpx plugin is added to libxine2-misc-plugins.
+  * Pulled in autoreconf changes fron Ubuntu.
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Tue, 08 Apr 2014 16:54:59 +0100
+
+xine-lib-1.2 (1.2.4-2) unstable; urgency=low
+
+  * vaapi isn't built (by default) on kfreebsd-*, so don't try to install it.
+    (Closes: #725071)
+  * Avoid a possible build failure in the vaapi plugin (delay code).
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Tue, 01 Oct 2013 21:32:41 +0100
+
+xine-lib-1.2 (1.2.4-1) unstable; urgency=low
+
+  * New upstream release.
+    - New plugins:
+      + vaapi (output), in libxine2-x. (New build-dep on libva-dev.)
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Tue, 24 Sep 2013 01:36:06 +0100
+
+xine-lib-1.2 (1.2.3-1) unstable; urgency=low
+
+  * New upstream release.
+    - Some fixes for large images & Xv. (Closes: #666742)
+    - Works with libav 0.9 (I hope). (Closes: #693075)
+    - New plugins:
+      + test (input), in libxine2-misc-plugins;
+      + libjpeg (decoder), in libxine2-misc-plugins;
+      + opengl2 (output), in libxine2-x.
+  * Switch to xz for .deb compression.
+  * Drop old patches since they were all from the upstream repository.
+  * Fix configuration so that the xvmc video output plugin is built.
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Wed, 29 May 2013 16:07:29 +0100
+
+xine-lib-1.2 (1.2.2-4) unstable; urgency=low
+
+  * Backported patches from upstream:
+    - Fix raw YUV decoding.
+    - Fix greedy2frame SSE2 when only 4 registers are available.
+    - Add missing string termination (FourCC).
+    - Free all DR1 frames (affects VP6, WMV).
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Sat, 30 Jun 2012 19:12:11 +0100
+
+xine-lib-1.2 (1.2.2-3) unstable; urgency=low
+
+  * debian/control didn't have my new address...
+  * Update VCS headers to point at the shiny new all-in-one repository.
+  * Update home page...
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Sun, 10 Jun 2012 19:14:07 +0100
+
+xine-lib-1.2 (1.2.2-2) unstable; urgency=low
+
+  * Fix FTBFS on !x86* (upstream patch 0001-fix-non-x86-build.patch).
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Sun, 10 Jun 2012 18:29:00 +0100
+
+xine-lib-1.2 (1.2.2-1) unstable; urgency=low
+
+  * New upstream release.
+    - Patches dropped (no longer needed).
+    - Now uses rsvg-convert. (Closes: #666485)
+      However, rsvg-convert isn't a drop-in replacement for rsvg.
+    - Goom visualisation plugin double-free when playing some AAC files is
+      fixed. (Closes: #662037)
+    - Have xine-list-1.2 not write ~/.xine/catalog.cache. (Closes: #658111)
+
+ -- Darren Salt <devspam@moreofthesa.me.uk>  Sat, 09 Jun 2012 20:53:14 +0100
+
+xine-lib-1.2 (1.2.1-2) unstable; urgency=low
+
+  * Removed the 'development version' info from the package descriptions.
+    That's not been true since 1.2.0 was released.
+  * Lintian warning fixups:
+    - Adjusted package descriptions.
+  * Added a symbols file for libxine2-bin.
+  * Build-depend on libpng-dev. (Closes: #662560)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 27 Mar 2012 22:50:01 +0100
+
+xine-lib-1.2 (1.2.1-1) unstable; urgency=low
+
+  * New upstream release.
+    - All patches dropped. Either they're from upstream anyway or they no
+      longer matter.
+  * For those interested in the source: new packaging repository :-)
+    - No longer use monolithic patching. That worked well with
+      hg-buildpackage, but seems not to with mercurial-buildpackage.
+  * Put libxine2-x and libxine2-console in section 'video'. (Bug 657118)
+  * Remove libxine2-plugins dependency on libxine2. (Closes: #658179)
+  * Removed unnecessary dependencies from libxine2-dev.
+  * Got the DVB plugin working again. (upstream_dvb-fix-endianness.patch)
+    (Closes: #658709)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 08 Feb 2012 22:24:54 +0000
+
+xine-lib-1.2 (1.2.0-5) unstable; urgency=low
+
+  * Upload to unstable.
+  * libxine-dev is now libxine2-dev, so that libxine-dev (1.1) can remain
+    for a while longer.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 25 Jan 2012 00:23:53 +0000
+
+xine-lib-1.2 (1.2.0-4) experimental; urgency=low
+
+  * Enable BluRay support.
+  * Simplify dep on libjack-dev, but prefer libjack-jackd2-dev.
+  * Enable hardened build flags.
+  * Correctly install xine.pm for 'dh --with xine'. (Closes: #636910)
+  * xine-list-1.2 no longer causes catalog.cache to be written. (Closes: #656501)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 22 Jan 2012 21:03:47 +0000
+
+xine-lib-1.2 (1.2.0-3) experimental; urgency=low
+
+  * This time, with autoreconf.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 03 Jan 2012 17:24:32 +0000
+
+xine-lib-1.2 (1.2.0-2) experimental; urgency=low
+
+  * Enable JACK, VDPAU and PulseAudio on hurd-i386. (Closes: #654191)
+  * Whoops. Forgot to update shlibs info, causing installation fail.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 03 Jan 2012 00:12:19 +0000
+
+xine-lib-1.2 (1.2.0-1) experimental; urgency=low
+
+  * New upstream release.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 01 Jan 2012 21:24:50 +0000
+
+xine-lib-1.2 (1.1.90hg+20110516+847d4f89a4fb-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Plus a few small build fixes.
+  * Use GraphicsMagick instead of ImageMagick, making this bug irrelevant:
+    (Closes: #625554)
+  * Don't try to install the PVR or V4L input plugins (not built).
+  * Force use of libav 0.7. Not strictly necessary, but good for testing.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Mon, 16 May 2011 16:25:31 +0100
+
+xine-lib-1.2 (1.1.90hg+20100720+609066b321de-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+  * Temporarily disable the "broken libmodplug 0.8.8" check.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 20 Jul 2010 19:58:02 +0100
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-7) experimental; urgency=low
+
+  * Don't depend on libpulse-dev on hurd-i386.
+  * Add dh 7 support (dh --with xine).
+  * Allow dh_xine to take package name suffixes.
+    The defaults are 'x' and 'console'.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 30 Mar 2010 19:03:14 +0100
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-6) experimental; urgency=low
+
+  * More FTBFS fun.
+  * Correct addition of --enable-libv4l and *don't* install V4L2 on kfreebsd.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 20 Mar 2010 22:27:32 +0000
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-5) experimental; urgency=low
+
+  * Enable the JACK plugin and install the V4L2 plugin on kfreebsd-*.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 20 Mar 2010 15:37:25 +0000
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-4) experimental; urgency=low
+
+  * Enable vcdo & pulseaudio plugins on kfreebsd-*.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 20 Mar 2010 01:20:56 +0000
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-3) experimental; urgency=low
+
+  * Enable VDPAU on kfreebsd-*. (Attempt 2.)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 19 Mar 2010 22:31:31 +0000
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-2) experimental; urgency=low
+
+  * Enable VDPAU on kfreebsd-*; don't try to install it on hurd-i386.
+  * On Linux, use libv4l.
+  * Tell dpkg-source to use a single patch file.
+  * Add build-dep on libfaad-dev.
+  * Remove obsolete Conflicts/Replaces on libxine-extracodecs.
+  * Tidy up dh_clean invocation.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 10 Mar 2010 14:11:07 +0000
+
+xine-lib-1.2 (1.1.90hg+20100309+8d16822f2be7-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Synced with 1.1.18.1.
+    - 1.1.17 works with the new mpcdec API, so this should too.
+      (Closes: #520600)
+  * GNU/Hurd build changes ported from 1.1.17.
+  * debian/rules:
+    - don't set CFLAGS (defaults are fine);
+    - add --enable-debug if DEB_BUILD_OPTS contains 'noopt'.
+  * Put new plugins in the appropriate places: VDPAU in libxine2-x, VC1ES
+    demuxer in libxine2-ffmpeg, V4L2 input in libxine2-misc-plugins.
+  * Build-depend on libvdpau-dev.
+  * Bump standards version to 3.8.4.
+    - Depend on ${misc:Depends} everywhere.
+    - Put libxine2-dbg in section 'debug'.
+    - Tighten dependency of libxine-dev on libxine2-bin.
+      (Closes: #478026, #529361)
+    - Ignore a few warnings related to how the binaries and documentation
+      are split between packages.
+  * Don't try to install the DVB plugin on kfreebsd-* since it's not built
+    there. (Closes: #565815)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 09 Mar 2010 16:44:02 +0000
+
+xine-lib-1.2 (1.1.90hg+20091119+7af2793bc117-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Synced with 1.1 hg (includes 1.1.16.3).
+  * Add dh_xine, for use when building front ends.
+  * Add hdmv subtitles decoder to -misc-plugins.
+  * Switch to source format v3 (quilt).
+  * [Build] Remove po/Makevars.extra when cleaning up.
+  * Have libxine2 depend on libxine2-bin (for /usr/share/doc symlinking).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 19 Nov 2009 16:45:43 +0000
+
+xine-lib-1.2 (1.1.90hg+20090218+678f7a60fde4-3) experimental; urgency=low
+
+  * libmpeg2new build fix on sparc & alpha.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 03 Mar 2009 20:12:17 +0000
+
+xine-lib-1.2 (1.1.90hg+20090218+678f7a60fde4-2) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Synced with the 1.1.16.2 release; contains all relevant security fixes.
+  * Oops. The sparc-specific hack caused configure to be run twice, thus not
+    actually fixing the problem at all. The hack needs to be undone in the
+    clean target, after running "make distclean".
+    (Closes: #453158, #460633.)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 18 Feb 2009 13:22:36 +0000
+
+xine-lib-1.2 (1.1.90hg+20090118+608e90e5e160-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Synced with the 1.1.16.1 release; contains all relevant security fixes.
+  * Added --build & --host to the configure flags.
+  * Really ugly hack to try to get this building on sparc.
+    (Bugs 453158 & 460633.)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 18 Jan 2009 17:37:31 +0000
+
+xine-lib-1.2 (1.1.90hg+20090116+01754b5a1b0e-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    - Synced with the 1.1.16 release; contains all relevant security fixes.
+    - Dropped JACK output diff, which hasn't been needed for a while.
+    - Dropped PulseAudio output priority reversion.
+    - Bumped ffmpeg dependencies to require the versions in experimental.
+  * Install the mpeg2new decoder (not that it currently works very well).
+  * Install the "raw" video output plugin in -misc-plugins.
+  * Remove the dependency on libjack0.100.0-dev and limit to non-broken
+    versions (though no problems are expected).
+  * Revert an upstream change which breaks building with ImageMagick in
+    experimental.
+  * Standards version 3.8.0.
+    - Tweaked dependency on libcdio-dev to quieten lintian.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 16 Jan 2009 17:05:15 +0000
+
+xine-lib-1.2 (1.1.90hg+20080814+4542a8b61c15-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    (cset 4542a8b61c1518bc92ce1a76f5bac9a08f5b576f)
+    - Synced with the 1.1.15 release; contains all relevant security fixes.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 14 Aug 2008 23:31:22 +0100
+
+xine-lib-1.2 (1.1.90hg+20080612+4062642bf8eb-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    (cset 4062642bf8ebf409ecb38d21680d18d9eb62d0c1)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 12 Jun 2008 03:23:47 +0100
+
+xine-lib-1.2 (1.1.90hg+20080524+5e58815f81a9-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    (cset 5e58815f81a9a8c1d7cdeba19da83d7ef7d07260)
+  * Don't link with libstdc++ or libm when linking with libmodplug.
+    (Workaround for bug 457278 and buggy build environments, fixing FTBFS.)
+  * Build-depend on libmagickwand-dev instead of libmagick9-dev.
+  * Resync debian/* with 1.1; distribute xine-lib-1.2.
+  * Disabled nsf.
+  * Replaced the JACK audio-put plugin (bug 462663).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 24 May 2008 20:23:30 +0100
+
+xine-lib-1.2 (1.1.90hg+20080402+f29350241e48-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    (cset f29350241e4875e5e2df3715830a0926bea94680)
+    - Synced with the 1.1.11.1 release; contains all relevant security fixes.
+  * Restore pulseaudio priority (changed since 1.1.11.1) to its 1.1.11.1
+    value. Otherwise, things break when pulseaudio isn't running.
+  * Bump minimum versions on the build-depends on ffmpeg -dev packages so
+    that the packages in experimental are used.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 02 Apr 2008 21:06:42 +0100
+
+xine-lib-1.2 (1.1.90hg+20080321+5ac9723858b2-1) experimental; urgency=low
 
-xine-lib-1.2 (1.2.8+hg-0) experimental; urgency=low
+  * 1.2.x development branch snapshot.
+    (cset 5ac9723858b289882a26cd006c08a51d7a76e784)
+    - Synced with the 1.1.11 release; contains all relevant security fixes.
 
-  * Hg snapshot.
-  * Adjust for libxine2.
-  * libxine-dev → libxine2-dev.
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 21 Mar 2008 00:18:41 +0000
 
- -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 26 Feb 2017 00:57:46 +0000
+xine-lib-1.2 (1.1.90hg+20080229+9fc6fdc5c795-1) experimental; urgency=low
 
-xine-lib (1.1.21~hg-0) unstable; urgency=low
+  * 1.2.x "St. Tib's Day" development branch snapshot.
+    (cset 9fc6fdc5c7959b3a2df03c0740377b4424e28c44)
+  * Using bzip2 compression for the .debs.
 
-  * Hg snapshot (dev build). Changelog is irrelevant :-)
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 29 Feb 2008 19:53:46 +0000
 
- -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 17 Jan 2012 19:06:22 +0000
+xine-lib-1.2 (1.1.90hg+20080214+db71e67bee03-1) experimental; urgency=low
 
-xine-lib (1.1.5~cvs-0) unstable; urgency=low
+  * 1.2.x development branch snapshot.
+    (cset db71e67bee037142234750a216597c7811cc7df5)
+    - CVE-2008-0486: Array index vulnerability which may allow remote
+      attackers to execute arbitrary code via a crafted FLAC tag, which
+      triggers a buffer overflow. (Closes: #464696)
 
-  * CVS snapshot.
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 14 Feb 2008 22:17:50 +0000
+
+xine-lib-1.2 (1.1.90hg+20080127+4dbd3fc1ce2b-1) experimental; urgency=low
+
+  * 1.2.x development branch snapshot.
+    (cset 4dbd3fc1ce2b9a6102247159cb56a7cb0e9d6be8)
+    - SECURITY FIX: ASF header-parsing overflow (related to CVE-2006-1664)
+    - syncfb plugin has been removed
+  * Start including the cset ID in the version no.
+  * Put libxine2-doc back in section doc. I'd moved it to match the
+    override... Also, correct libxine2-dev -> doc (20080111-1 entry).
+  * Patches dropped (already committed upstream).
+  * Standards version 3.7.3 (no changes needed).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Mon, 28 Jan 2008 01:16:06 +0000
+
+xine-lib-1.2 (1.1.90hg+20080111-1) experimental; urgency=low
+
+  [Darren Salt]
+  * 1.2 development branch snapshot.
+    (cset 1dad98a822c64406810fff529669bfc6f2509a9e)
+    - SECURITY FIX: rtsp header-parsing overflow (CVE-2008-0225)
+  * Put libxine2-doc in section libdevel.
+  * Adjust libxine2-vdr & libxine2-misc-plugins install files for recent
+    changes in the vdr & sputext plugins' organisation.
+  * Patches from upstream:
+    - fix some WMV rendering bugs (cset 4ea95338a408)
+  * Have libxine-dev depend on pkg-config. This is needed for xine-config.
+  * Add the Technotrend PVA demuxer to libxine2-misc-plugins.
+
+  [Reinhard Tartler]
+  * Bug fix: "FTBFS with dpkg-buildpackage -j; build target doesn't properly
+    depend on configure target", thanks to Michel Dänzer (Closes: #457281).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 13 Jan 2008 13:27:40 +0000
+
+xine-lib-1.2 (1.1.90hg+20071219-1) experimental; urgency=low
+
+  [Darren Salt]
+  * 1.2 development branch snapshot.
+    (cset b4c8c6b8358f873afc46152075c76aebf820cbdf)
+  * Port changes from the 1.1.x branch:
+    - libxine2-dbg was missing some debug symbols. Fixed by building it
+      after xine-lib's other arch:any packages.
+    - Introduce a new package, libxine2-bin, which contains the binaries
+      formerly in libxine2. Dependencies are moved and updated accordingly.
+    - Except for libxine2-doc, libxine2-bin and libxine-dev, symlink to
+      libxine2-bin's documentation. (AUTHORS is now in libxine2-bin.)
+    - Add libxine2-all-plugins; drop dependency on libxine2-gnome from
+      libxine2-plugins. (Bug 454162)
+    - Adjust dependencies on libxine2-dev and libxine2-dbg.
+    - Typo "a various plugins" in package description. (Bug 455067)
+  * Re-add the pulseaudio plugin (it's been somewhat rewritten).
+  * Add the playlist demux plugin.
+
+  [ Reinhard Tartler ]
+  * Add DM-Upload-Allowed: yes field to debian/control.
+  * Remove automake, autoconf and libtool from build-dependencies.
+  * remove libartsc0-dev from build depends.
+  * readd libpuse-dev build depends.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 19 Dec 2007 17:39:10 +0000
+
+xine-lib-1.2 (1.1.90hg+20071125-1) experimental; urgency=low
+
+  [ Darren Salt ]
+  * 1.2 development branch snapshot.
+    (cset 0b1ecd21a6263d065aa76152de340dc33a6274f7)
+  * Drop build dependency on gs.
+
+  [ Reinhard Tartler ]
+  * Add build dependency on libvcdinfo-dev
+  * remove the pulse audio plugin, as done in the upload to unstable.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Mon, 26 Nov 2007 13:49:48 +0100
+
+xine-lib-1.2 (1.1.90hg+20071025-1) UNRELEASED; urgency=low
+
+  * 1.2 development branch snapshot.
+    (cset ae9a2fddb2b6b50dab2a7ac649b2307719c78fe2)
+  * Pull in changes, post 1.1.8-1, which aren't already present:
+    - Move libxine2-doc into section "doc".
+    - Improve package descriptions a bit; in particular, a grammatical
+      correction for libxine2-console, and an extra sentence describing common
+      uses of libxine2-ffmpeg.
+    - New packages "libxine2-x" and "libxine2-misc-plugins";
+      dependencies updated accordingly.
+    - Remove outdated alternative dependencies from libxine-dev.
+    - Move the fb video output plugin into libxine2-console.
+    - Add Homepage field to debian/control
+    - Extra MPEG video identifier (seen in an AVI).
+  * Unlike 1.1.8-2, no dependencies on libxine2-x or libxine2-console.
+  * Correct a few errors in the changelog entry for the previous upload.
+  * Tighten the dependencies of libxine1 and libxine1-plugins on libxine1-*
+    packages.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Mon, 29 Oct 2007 18:12:54 +0000
+
+xine-lib-1.2 (1.1.90hg+20070930-1) experimental; urgency=low
+
+  [ Darren Salt ]
+  * 1.2 development branch snapshot.
+    (cset 717b46d826e66cb37632dab4f7a1ad78fdaa17cd)
+  * Adjust installed files to reflect merged/renamed demuxer & decoder
+    plugins.
+  * New package libxine2-vdr.
+
+  [ Reinhard Tartler ]
+  * use dh_listpackages(1) instead of hardcoded list in debian/rules
+  * remove workaround for mips. That should be fixed by now.c
+  * make libxine-dev arch: any. Rationale: This breaks building frontends
+    on architectures on which xine-lib is not up-to-date (yet).
+
+ -- Reinhard Tartler <siretart@tauware.de>  Tue, 02 Oct 2007 14:35:57 +0200
+
+xine-lib (1.1.12-3) unstable; urgency=low
+
+  * Build-depend on libmagick9-dev | libmagick-dev | libmagickwand-dev.
+  * Fixes from upstream hg:
+    - Fix display of some MJPEG streams.
+    - Fix a title usage bug in the ogg demuxer.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 22 May 2008 23:01:57 +0100
+
+xine-lib (1.1.12-2) unstable; urgency=high
+
+  * Fixes from upstream hg:
+    - CVE-2008-1878: Buffer overflow in the NSF demuxer which may allow
+      remote attackers to cause a denial of service (crash) or possibly
+      execute arbitrary code via an NSF file with a long title or copyright
+      message.
+      (Our chosen option is to patch and disable this code.)
+    - Backport more calloc usage from the 1.2 branch for extra safety
+      against possible integer overflows such as found in CVE-2008-1482.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 27 Apr 2008 14:20:41 +0100
+
+xine-lib (1.1.12-1) unstable; urgency=high
+
+  * New upstream release.
+    - CVE-2008-1686: Insufficient boundary check in speex audio decoder.
+    - New tool "xine-list-1.1", which front-end maintainers will find useful
+      for updating .desktop files at install time and in conjunction with
+      dpkg triggers.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Mon, 14 Apr 2008 23:39:44 +0100
+
+xine-lib (1.1.11.1-3) unstable; urgency=medium
+
+  * Fixes from upstream hg:
+    - Matroska demuxer regression. (Closes: #474316)
+    - PulseAudio plugin backported & re-enabled.
+      This takes precedence over ALSA, but falls back cleanly.
+  * Re-enabled & replaced the JACK audio-put plugin. (Closes: #462663)
+    This has not yet been committed upstream.
+  * Don't link with libstdc++ or libm when linking with libmodplug.
+    (Workaround for bug 457278 and buggy build environments, fixing FTBFS.)
+  * Urgency=medium; t-p-u has a security-patched version, but it also has
+    backported bugs...
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 09 Apr 2008 15:35:07 +0100
+
+xine-lib (1.1.11.1-2) unstable; urgency=high
+
+  * Fixes from upstream hg:
+    - Quicktime demuxer regression. (Closes: #473499, #473631)
+    - Wavpack MIME type information.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Tue, 01 Apr 2008 15:05:02 +0100
+
+xine-lib (1.1.11.1-1) unstable; urgency=high
+
+  * New upstream release.
+    - CVE-2008-1482: integer overflows in FLV, Qt, Real, WC3Movie, Matroska
+      and FILM demuxers, allowing remote attackers to trigger heap overflows
+      and possibly execute arbitrary code. (Closes: #472639)
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sun, 30 Mar 2008 15:15:04 +0100
+
+xine-lib (1.1.11-1) unstable; urgency=high
+
+  * New upstream release.
+    - CVE-2008-0073: Array index vulnerability which may allow remote
+      attackers to execute arbitrary code via a crafted SDP parameter in an
+      RTSP stream.
+    - DVD reader code no longer uses UDF-provided file sizes as
+      authoritative. (Closes: #463177)
+
+  [Darren Salt]
+  * Remove the versioning from the libmagick9-dev build-dep.
+  * Disable the pulseaudio plugin (don't build, don't install) and remove
+    the build-dep on libpulse-dev for now due to instability: xine-lib has
+    been observed closing the stream due to audio problems.
+    (Closes: #471676)
+
+  [ Reinhard Tartler ]
+  * add support for 'parallel' keyword in DEB_BUILD_OPTIONS
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 20 Mar 2008 22:39:24 +0000
+
+xine-lib (1.1.10.1-2+lenny2) testing-security; urgency=high
+
+  * Non-maintainer upload by the Security Team.
+  * This update addresses the following security issues:
+    - CVE-2008-1878: stack-based buffer overflow in nsf demuxer that
+      allows execution of arbitrary code via a crafted title (Closes: #476990)
+    - CVE-2008-1686: insufficient boundary checking on a header structure that
+      is read from user input could lead to arbitrary code to arbitrary
+      code execution via negative values (Closes: #475152).
+    - CVE-2008-0073: stack-based buffer overflow in subtitle parsing could
+      lead to arbitrary code execution via a crafted subtitle
+      file (Closes: #473057).
+
+ -- Nico Golde <nion@debian.org>  Sun, 04 May 2008 13:20:43 +0200
+
+xine-lib (1.1.10.1-2+lenny1) testing-security; urgency=high
+
+  * Non-maintainer upload by the Security Team.
+  * Fix various integer overflows in FLV, Qt, Real, WC3Movie, Matroska and FILM
+    demuxers, allowing remote attackers to trigger heap overflows and
+    possibly execute arbitrary code and other possible NULL pointer
+    dereferences caused my missing alloc checks.
+    (CVE-2008-1482; Closes: #472639)
+
+ -- Nico Golde <nion@debian.org>  Tue, 01 Apr 2008 14:38:40 +0200
+
+xine-lib (1.1.10.1-2) unstable; urgency=low
+
+  [Darren Salt]
+  * libxine-dev: backport an m4 version-parsing fix from hg.
+  * Fixed an off-by-one (introduced in the security fix) which breaks
+    playback of some FLAC files. (Closes: #466746)
+  * Versioned build-dep on libmagick9-dev (for libmagick10). (Closes: #466681)
+    Add libmagick-dev as an alternative, with the same version requirement.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Wed, 20 Feb 2008 23:43:05 +0000
+
+xine-lib (1.1.10.1-1) unstable; urgency=high
+
+  * New upstream release.
+    - CVE-2008-0486: Array index vulnerability which may allow remote
+      attackers to execute arbitrary code via a crafted FLAC tag, which
+      triggers a buffer overflow. (Closes: #464696)
+    - Real codec detection was looking in the wrong places. (Closes: #462964)
 
   [Darren Salt]
-  * Resync build deps with 1.1.4-2.
-  * Add or update some minimum version numbers.
-  * Add a build dependency on libdirectfb-dev.
+  * Add pkg-config dependency to libxine-dev, fixing xine-plugin FTBFS.
+    (Closes: #464178, #464321)
+  * Put libxine1-doc back into section doc until somewhere better is created
+    for it. (Closes: #462710)
+  * No longer build-conflict with libxine-dev from xine-lib-1.2. This is no
+    longer needed due to link order changes.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 08 Feb 2008 17:25:21 +0000
+
+xine-lib (1.1.10-1) unstable; urgency=high
+
+  * New upstream release (Closes: #459836)...
+  * ... fixing some security bugs:
+    - CVE-2008-0225: Heap-based buffer overflow in rmff_dump_cont function
+      which allows remote attacker to execute arbitrary code via a crafted
+      SDP Abstract attribute (Closes: #460551).
+      This also acks 1.1.8-3+lenny1 (NMU by the security team).
+    - Related to CVE-2006-1664: Buffer overflow which allows a remote
+      attacker to execute arbitrary code or crash the client program via a
+      crafted ASF header.
+  * ... and fixing some other bugs, including:
+    - Disappearing audio. (Closes: #461970)
 
- -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Fri, 16 Mar 2007 01:33:24 +0000
+  [ Darren Salt ]
+  * Build-depend on gs-gpl | gs. Avoids FTBFS where recommended packages
+    aren't automatically installed.
+  * Put libxine1-doc in section libdevel.
+  * Move libxine1-doc | libxine-doc to Suggests: in libxine1. (Closes: #458103)
+  * Add postinst scripts to ensure that the documentation symlinks are
+    properly created. (This is really dpkg bugginess.) (Closes: #458865)
+  * Standards version 3.7.3; no changes needed.
+
+  [ Reinhard Tartler ]
+  * Actually install xineplug_decode_w32dll.so and xineplug_decode_qt.so
+    on i386. debian/rules accidentally used $< where it should have been
+    $^. Thanks to Gert Kulyk for reporting!                  LP: #182400
+  * Fix XS-Hg-VCS headers in debian/control                  LP: #183886
 
-xine-lib (1.1.3-0) unstable; urgency=medium
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 26 Jan 2008 22:16:28 +0000
+
+xine-lib (1.1.9-1) unstable; urgency=low
 
   * New upstream release.
 
   [Darren Salt]
-  * debian/rules: work around version number breakage in libavcodec.pc.
+  * Re-enable the pulseaudio plugin.
+
+  [Reinhard Tartler]
+  * Remove really unnecessary versioned build depends on binutils. Even
+    oldstable (sarge) has a newer version available.
+  * Bug fix: "unable to handle ipv6 MRLs", thanks to Mau (Closes:
+    #448801).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 10 Jan 2008 21:57:10 +0000
+
+xine-lib (1.1.8-5) unstable; urgency=low
+
+  [Darren Salt]
+  * Build fix: avoid lots of "make install" invocations (introduced in -4).
+  * Fix dependency issues with respect to documentation symlinks.
+    The problem was an incorrect debian/shlibs.local.	(Closes: #457328)
+  * Use a symlink for libxine1-dbg's documentation (this got missed in -4).
+  * libxine1-bin (-4) should have contained AUTHORS. This is fixed.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 22 Dec 2007 17:49:54 +0000
+
+xine-lib (1.1.8-4) unstable; urgency=low
+
+  [Darren Salt]
+  * libxine1-dbg was missing some debug symbols. Fixed by building it after
+    xine-lib's other arch:any packages.
+  * Introduce a new package, libxine1-bin, which contains the binaries
+    formerly in libxine1. Dependencies are moved and updated accordingly.
+    thanks to Bill Allombert.  (Closes: #454267)
+  * Except for libxine1-doc, libxine1-bin and libxine-dev, symlink to
+    libxine1-bin's documentation. (AUTHORS is now in libxine1-bin.)
+  * Backported patches from upstream 1.1 branch:
+    - Fix compilation of DXR3 support with external ffmpeg.
+      This is currently only needed for compilation against libavcodeccvs-dev
+      (from debian-multimedia). Untested with actual DXR3 hardware since I
+      have none.                                           (cset e55bc398cc7c)
+    - Fix a problem with non-seekable Flash video          (cset de8c671a419c)
+    - Fix "missing" channels.conf with ATSC                (cset fd875c4a15bc)
+    - Fix a possible crash when changing channels (DVB)    (cset bf1ec833d87a)
+    - Don't stop reading Ogg streams early                 (cset e4c8ac4a6b49)
+    - Fix a possible crash when a video output is closed   (cset 06494c094761)
+    - Fix a possible crash when video playback is finished (cset 293845e465cc)
+
+  [ Reinhard Tartler ]
+  * Bug fix: "FTBFS with GCC 4.3: missing #includes", thanks to Martin
+    Michlmayr and Daniel Schepler (Closes: #455438, #455322).
+  * Bug fix: "libxine1-plugins: should not depend on libxine1-gnome",
+    thanks to Hermogenes Hebert Pereira Oliveira. (Closes: #454162).
+    Instead, a new package is introduced: libxine1-all-plugins, which
+    additionally depends on the gnome plugin.
+  * remove the jack plugin. According to upstream it is unfinished and of
+    poor quality. A rewrite is available in the 1.2 branch.
+  * adjust dependencies on libxine1-dev and libxine1-dbg
+  * add XS-DM-Upload-Allowed: yes field to debian/control
+  * Bug fix: "xine-lib: FTBFS on GNU/kFreeBSD (debian specific part)",
+    thanks to Petr Salinger (Closes: #449531). Patch applied with some
+    (minor) modifications.
+  * Bug fix: "libxine1: FTBFS on GNU/kFreeBSD", thanks to Uwe Hermann
+    (Closes: #438849). Patch taken from upstream hg repo, cset
+    1db8870cd7c9
+  * Bug fix: "typo "A various plugins" in package description",
+    thanks to Philippe Cloutier (Closes: #455067).
+
+ -- Reinhard Tartler <siretart@tauware.de>  Mon, 17 Dec 2007 17:07:48 +0100
+
+xine-lib (1.1.8-3+lenny1) testing-security; urgency=high
+
+  * Non-maintainer upload by security team.
+  * This update addresses the following security issue:
+    - CVE-2008-0225: Heap-based buffer overflow in rmff_dump_cont function
+    which allows remote attacker to execute arbitrary code via a crafted
+    SDP Abstract attribute (Closes: #460551).
+
+ -- Nico Golde <nion@debian.org>  Sun, 13 Jan 2008 16:12:48 +0100
+
+xine-lib (1.1.8-3) unstable; urgency=low
+
+  [Darren Salt]
+  * Patches from the 1.1.9 dev tree:
+    - Silence "lacing: N" messages from the matroska demuxer.
+    - Extra identifier for MPEG video (in AVIs etc.).
+  * Tighten the dependencies of libxine1 and libxine1-plugins on libxine1-*
+    packages.
+  * Move deps on libxine1-{x,console} from libxine1-plugins to libxine1 to
+    avoid further problems such as bug 448077.
+
+  [ Reinhard Tartler ]
+  * remove gs from build-deps
+  * don't build the pulseaudio plugin. (Closes: #452211, #427991)
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun, 25 Nov 2007 23:20:54 +0100
+
+xine-lib (1.1.8-2) unstable; urgency=low
+
+  [Reinhard Tartler]
+  * use dh_listpackages instead of hardcoded list for determining the
+    provided binary packages.
+  * Bug fix: "Depends->Recommends dependency change breaking other
+    packages", thanks to Christoph Pfister and Sune Vuorela
+    (Closes: #439389)
+    - introduce new package libxine1-misc-plugins, which contains
+      (nearly) all plugins formerly found in the package libxine1.
+    - promote all dependencies of libxine1-misc-plugins to Depends.
+    - Make libxine1 depend on libxine1-plugins | libxine1-misc-plugins.
+      Apt will prefer the first alternative, which results many
+      plugins installed by default. Caveat: If one plugin package has
+      unsatisfiable dependencies, the user will end up with only
+      libxine1-misc-plugins installed.
+    - Make libxine1-plugins depend on libxine1-misc-plugins.
+    - Make libxine1-plugins not depend on libxine1-console.
+    - NB: From now on, frontends need to explicitly depend on either
+      libxine1-x or libxine1-console, depending on whether they are
+      console based (like cacaxine or fbxine) or X11 based (like gxine).
+      libxine1-plugins will not depend on libxine1-x or libxine1-console.
+  * Make libxine1-dev Arch:any. Being arch:all makes a lot of trouble
+    building frontends on architectures that are out of sync.
+  * Remove alternative depends on libz-dev (not found even in oldstable)
+    and slang1-dev (not found in stable, only oldstable) from libxine1-dev.
+  * Add Homepage field to debian/control
+
+  [Darren Salt]
+  * Add patches from upstream:
+    - DVD MRL title.chapter fix
+  * Move libxine1-doc into section "doc".
+  * Improve package descriptions a bit; in particular, a grammatical
+    correction for libxine1-console, and an extra sentence describing common
+    uses of libxine1-ffmpeg.
+  * New package libxine1-x, which contains the X-based video output plugins.
+    These were previously in libxine1.
+  * Move the fb video output plugin into libxine1-console.
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Sat, 20 Oct 2007 18:01:27 +0100
+
+xine-lib (1.1.8-1) unstable; urgency=low
+
+  * New upstream release. (Closes: #440248)
+
+  [Darren Salt]
+  * Remove config.log when cleaning the build tree.
+
+  [Reinhard Tartler]
+  * Bug fix: "libxine1: copyright file references non-existent AUTHORS
+    file", thanks to Felipe Sateler (Closes: #438677).
+
+ -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Mon, 27 Aug 2007 20:59:37 +0100
+
+xine-lib (1.1.7-3) unstable; urgency=low
+
+  * promote dependencies of xineplug_dmx_audio.so from Suggests to
+    Recommends. This is necesarry for e.g. mp3 files or streams
+    (Closes: #437906, #437693),  thanks to François Valenduc and
+    Paulo Marcel Coelho Aragão.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Wed, 15 Aug 2007 09:51:53 +0200
+
+xine-lib (1.1.7-2) unstable; urgency=low
+
+  [Darren Salt]
+  * Enable the wavpack plugin. (Closes: #437331)
+  * Correct the description of libxine-doc. (Closes: #432919, #435590)
+  * Build-depend on libjack-dev.
+  * Enable freetype support. (Closes: #416077)
+  * Add patches from upstream:
+    - allow using ffmpegvideo w/o direct rendering to play mpeg2 ts;
+    - handle escaped characters in DVD MRLs;
+    - fix attempted free of static data, e.g. when using "dvd:/";
+    - rename mrl_unescape & export it (needed by the previous fix).
+    These are csets acc7197f7cca, 2e301bc2cce8, 09e652c8188f & 82bc4a5c2b4c.
+
+  [ Reinhard Tartler ]
+  * libxine1: demote all dependencies of the plugins to Recommends.
+    This includes the directfb plugin and therefore Closes: #427982.
+  * introduce debian/shlibs.local.libxine1 to avoid self-dependency of
+    libxine1. Fixes a lintian warning.
+  * some small changes to package descriptions.
+  * debian/rules: Don't ignore potential failiures in clean when running
+    $(MAKE) distclean. Check for presence instead (thanks lintian).
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun, 12 Aug 2007 00:38:45 +0200
+
+xine-lib (1.1.7-1) unstable; urgency=low
+
+  * New upstream release.
+    - Built against new FLAC. (Closes: #426677)
+    - The arts plugin is no longer built by default.
+      (Closes: #257368, #354437, #396219)
+    - RealPlayer codec detection works properly now. (Closes: #416245)
+    - vcd playback has been fixed upstream (Closes: #364837)
+
+  [Darren Salt]
+  * Added libxine1-doc. This will be needed once 1.2 is released to avoid
+    problems with xine(5), and is useful now for development purposes.
+  * Made libxine-dev conflict with & replace libxine2-dev for similar reasons.
+  * Since the arts plugin is no longer built:
+    - removed libxine1-kde and the associated build-dep on libartsc0-dev;
+    - made libxine-plugins conflict with and replace libxine1-kde.
+  * Minor package description fixes.
+
+  [Reinhard Tartler]
+  * move the gdk plugin to the libxine-gnome package
+  * make watch file using the qa.debian.org sf redirector
+  * add -lpthread to PTHREAD_LIBS on mipsen
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 07 Jun 2007 16:05:20 +0200
+
+xine-lib (1.1.6-2) unstable; urgency=low
+
+  * upload to unstable since we finally have now all needed dependencies
+    available.
+  * restore a lot of the lost changelogs from
+    http://changelog.debian.net/xine-lib
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 31 May 2007 10:47:34 +0200
+
+xine-lib (1.1.6-1) experimental; urgency=low
+
+  [ Reinhard Tartler]
+  * add libxcb-xv0-dev, libxcb-shm0-dev, libxcb-shape0-dev to build
+    dependencies and enable xcb support
+  * make libxine1 an arch: all package, no architecture dependent part
+    inside there.
+  * make xine-lib binNMU safe
+  * fetch po/de.po from upstream hg repo, which was updated shortly after
+    the 1.1.6 release
+  * Darren added himself as comaintainer
+
+  [ Darren Salt]
+  * New upstream release.
+    - Patches dropped, since they all came from upstream.
+    - More debug compilation failures fixed. (Closes: #339523)
+  * Patches imported from upstream since 1.1.6 release:
+    - limit common-case buffer copying optimisation to i386 & amd64
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 19 Apr 2007 16:47:23 +0200
+
+xine-lib (1.1.5-2) experimental; urgency=low
+
+  * add libjack0.100.0-dev to build depends, fixes FTBFS
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 12 Apr 2007 14:40:33 +0200
+
+xine-lib (1.1.5-1) experimental; urgency=low
+
+  * new upstream release!
+  * whitespace-cleanup in debian/control
+  * Builds again on sparc (Closes: #410538)
+  * build again against externel ffmpeg found in experimental
+  * cleanup/clarify the package descriptions, mentioning the included plugins
+    (Closes: #410426)
+  * remove xineplug_decode_real_audio.so from debian/libxine1.install;
+    it has been dropped upstream.
+  * add libdirectfb-dev to build depends, enabling directfb support
+  * use external musepack libs
+  * import manpage fix from upstream
+  * add XS-Vcs headers pointing to alioth
+
+  [Darren Salt]
+  * Enabled the gdkpixbuf plugin.
+  * Split up the DirectFB code, building separate plugins for X11 and
+    console. (Applied upstream.)
+  * Added a note about the packaging repository to README.Debian.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun,  8 Apr 2007 19:21:08 +0200
+
+xine-lib (1.1.4-2) experimental; urgency=low
+
+  * merge changes from ubuntu
+  * make build deps multiline
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun,  4 Feb 2007 12:06:25 +0100
+
+xine-lib (1.1.4-1ubuntu2) feisty; urgency=low
+
+  * install shlibs.local file to tighten dependency on libxine1
+  * add build dependency on libmagick9-dev to build to
+    dmx_image and decoder_image plugin. Also add them to libxine1.install
+  * install the xine(5) manpage to package libxine1
+  * Bumb shlibs file (forgotten in 1.1.4-1)
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun,  4 Feb 2007 09:05:58 +0100
+
+xine-lib (1.1.4-1ubuntu1) feisty; urgency=low
+
+  * merge new upstream release from debian
+
+ -- Reinhard Tartler <siretart@tauware.de>  Mon, 29 Jan 2007 15:48:31 +0100
+
+xine-lib (1.1.4-1) experimental; urgency=low
+
+  * New upstream release!
+  * Tons of bugfixes, see /usr/share/doc/libxine1/changelog.gz
+  * Now playes sound in *.flv files (Closes: #396161)
+  * use internal ffmpeg copy for now, since debian's copy is too old :(
+    Will reenable building against debian's ffmpeg ASAP.
+  * add libpulse-dev to build depends, enable pulseaudio support
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sat, 27 Jan 2007 18:26:09 +0100
+
+xine-lib (1.1.3-1ubuntu2) feisty; urgency=low
+
+  * debian/control: Add libpulse-dev to build dependencies to enable
+    PulseAudio output support.
+  * debian/libxine1.install: Add xineplug_ao_out_pulseaudio.so to
+    list of installed plugins.
+
+ -- Daniel T Chen <crimsun@ubuntu.com>  Wed, 24 Jan 2007 23:31:42 -0500
+
+xine-lib (1.1.3-1ubuntu1) feisty; urgency=low
+
+  * Introduce new package libxine-extracodecs to faciliate upgrades
+  * merge from 1.1.3 branch for debian/experimental.
+  * additional patch: fix ftbfs on kFreeBSD
+
+  * ubuntu specific changes:
+
+    - libxine-main1 and libxine1-ffmpeg dummy package for upgrades from
+      dapper. Keep this package until (and including) the next LTS
+      release of ubuntu!
+
+ -- Reinhard Tartler <siretart@tauware.de>  Wed,  3 Jan 2007 22:12:20 +0100
+
+xine-lib (1.1.3-1) experimental; urgency=low
+
+    * New upstream fixes: "support for xvid files", thanks to
+      \[ATR\]Dj-Death (Closes: #319805).
+    * New upstream fixes: "libxine1: Jack output plugin missing", thanks to Tanu
+      Kaskinen (Closes: #392619).
+    * plays vorbis files again (Closes: #400274)
+    * Introduce new packages: libxine1-ffmpeg and libxine1-gnome to tighten
+      dependencies.
+      - splitting out libxine1-gnome works around Bug: "libxine1: remote
+      streams do not work without non-dependency libgnomevfs2-0", thanks to
+      Michael Marsh (adresses: #309040).
+      - splitting out libxine-kde works around bugs #257368, #354437
+    * Bump to debhelper compat 5
+    * disable gdk (fixing ftbfs) and vidix (as being unmaintained) for
+      now. Please contact me if you are willing and able to test it
+      extensively
+    * apply textrel patch from gentoo
+    * add transfig, gs, sgmltools-lite to build deps to build developer
+      documentation as well
+    * apply patch for freebsd support. Thanks to Aurelien Jarno <aurel32@debian.org>.
+      (Closes: #325489)
+
+    [Darren Salt]
+    * Updated the watch file - should work regardless of changes at Souceforge.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Wed,  3 Jan 2007 19:57:43 +0100
+
+xine-lib (1.1.3-0ubuntu1) feisty; urgency=low
+
+  * disable jack output plugin because jack is not in main
+  * merge from unreleased 1.1.3 branch targeted for debian. ubuntu
+    specific changes:
+
+    - libxine-main1 dummy package for upgrades from dapper. Keep this
+      package until (and including) the next LTS release of ubuntu!
+
+ -- Reinhard Tartler <siretart@tauware.de>  Tue,  2 Jan 2007 23:05:20 +0100
+
+xine-lib (1.1.3-0) UNRELEASED; urgency=low
+
+  * New upstream fixes: "support for xvid files", thanks to
+    \[ATR\]Dj-Death (Closes: #319805).
+  * plays vorbis files again (Closes: #400274)
+  * Introduce new packages: libxine1-ffmpeg and libxine1-gnome to tighten
+    dependencies.
+    - splitting out libxine1-gnome works around Bug: "libxine1: remote
+    streams do not work without non-dependency libgnomevfs2-0", thanks to
+    Michael Marsh (adresses: #309040).
+    - splitting out libxine-kde works around bugs #257368, #354437
+  * built against internal ffmpeg
+  * Bump to debhelper compat 5
+  * disable gdk (fixing ftbfs) and vidix (as being unmaintained) for
+    now. Please contact me if you are willing and able to test it
+    extensively
+  * apply textrel patch from gentoo
+  * add transfig, gs, sgmltools-lite to build deps to build developer
+    documentation as well
+  * make libxine1 recommend libxine1-ffmpeg so it gets installed by default
+  * apply patch for freebsd support. Thanks to Aurelien Jarno <aurel32@debian.org>.
+    (Closes: #325489)
+
+  [Darren Salt]
+  * Updated the watch file - should work regardless of changes at Souceforge.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Tue,  2 Jan 2007 22:14:14 +0100
+
+xine-lib (1.1.2+repacked1-0ubuntu2) edgy; urgency=low
+
+  * undo backport of this commit because of FTBFS on powerpc, ia64 and sparc:
+    -  [xine-lib @ 2006-07-12 21:08:46 by dsalt]
+       Tidy up the formatting of tvtime method help texts to allow better wrapping
+       by the front end.
+  * add recommends on libxine-extracodecs (recloses Malone #56699)
+
+ -- Reinhard Tartler <siretart@tauware.de>  Fri, 22 Sep 2006 20:10:04 +0200
+
+xine-lib (1.1.2+repacked1-0ubuntu1) edgy; urgency=low
+
+  * repacked the orig tarball. We can get rid of most diff by enabling
+    --enable-external-ffmpeg
+  * revert the caca related backport from upstream, we will keep the
+    old libcaca for edgy
+  * -dbg package is Priority: extra
+  * remerged with debian. Changes:
+    - ripped of plugins from the sources (see xine-extracodecs):
+      + ffmpeg
+      + faad
+      + libmad (mp3 plugin)
+    - fix FTBFS in src/post/deinterlace/plugins/greedy2frame_template.c by
+      adding src/post/deinterlace/plugins/mangle.h from
+      src/libffmpeg/libpostproc.
+    - libxine-main1 dummy package for upgrades from dapper. Keep this
+      package until (and including) the next LTS release of ubuntu!
+    - tighten build dependency on binutils according to dh_strip manpage
+    - insert a copy of libpostproc (from upstream source tarball) at
+      src/libpostproc. Actually, this is how it was in the previous ubuntu
+      package. Note that this is only for the planar postprocessing plugin,
+      which should be moved to the xine-extracodecs package in an later
+      upload.
+    - Adjust configure.ac, src/Makefile.am and src/post/planar/Makefile.am
+      for the new location of libpostproc
+
+ -- Reinhard Tartler <siretart@tauware.de>  Tue, 12 Sep 2006 22:28:12 +0200
+
+xine-lib (1.1.2+dfsg-4) unstable; urgency=low
+
+  * Very focused patches from upstream:
+  * src/input/net_buf_ctrl.c: Fix a div-by-zero crash
+  * xine-lib/src/input/input_http.c: http parsing fix
+  * don't disable alignment of stack variables. Patch applied upstream,
+    got extensive testing in ubuntu, upstream and experimental. Does avoid
+    a confusing warning in the ffmpeg plugin.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sun, 18 Mar 2007 00:49:32 +0100
+
+xine-lib (1.1.2+dfsg-3) unstable; urgency=high
+
+  * [CVE-2007-1246]: DMO decoder heap allocation overflow. Thanks for the
+    patch, Kees Cook and A Mennucc! (Closes: #414072)
 
- -- Darren Salt <linux@youmustbejoking.demon.co.uk>  Thu, 28 Dec 2006 00:16:11 +0000
+ -- Reinhard Tartler <siretart@tauware.de>  Fri,  9 Mar 2007 09:37:43 +0100
 
 xine-lib (1.1.2+dfsg-2) unstable; urgency=medium
 
@@ -438,7 +1735,7 @@
 xine-lib (1.0.1-1) unstable; urgency=high
 
   * new upstream release
-    * fixes MMST and RTSP vulnerabilities (CAN-2005-1195, closes #305343)
+    * fixes MMST and RTSP vulnerabilities (CAN-2005-1195, closes: #305343)
     * presumably fixes Ogg/Vorbis/Theora audio sync (closes: #301901)
     * fixes typo in xine-check subsystem (closes: #292341)
   * build-depends on libsdl1.2 (closes: #297435)
@@ -446,7 +1743,7 @@
   * moved documentation to policy compliant directories (closes: #303463)
   * made Vorbis and Theora hard dependancies (workaround closes: #288331)
 
- -- Siggi Langauf <siggi@localhost.localdomain>  Wed, 27 Apr 2005 12:41:46 +0200
+ -- Siggi Langauf <siggi@debian.org>  Wed, 27 Apr 2005 12:41:46 +0200
 
 xine-lib (1.0-1) unstable; urgency=high
 
diff -ruN o/debian/compat pc/debian/compat
--- o/debian/compat	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/compat	2024-07-21 14:42:55.838005503 +0300
@@ -1 +1 @@
-5
+10
diff -ruN o/debian/control pc/debian/control
--- o/debian/control	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/control	2024-07-21 14:42:55.838005503 +0300
@@ -73,7 +73,7 @@
 Suggests: ${shlibs:Suggests}, libxine2-doc | libxine-doc
 Conflicts: libxine2-all-plugins, libxine2-bin, libxine2-console, libxine2-ffmpeg, libxine2-gnome, libxine2-misc-plugins, libxine2-plugins, libxine2-x
 Replaces: libxine2-all-plugins, libxine2-bin, libxine2-console, libxine2-ffmpeg, libxine2-gnome, libxine2-misc-plugins, libxine2-plugins, libxine2-x
-Provides: libxine2-all-plugins, libxine2-bin, libxine2-console, libxine2-ffmpeg, libxine2-gnome, libxine2-misc-plugins, libxine2-plugins, libxine2-x, libxine2-vdr
+Provides: libxine2-all-plugins, libxine2-bin, libxine2-console, libxine2-ffmpeg, libxine2-gnome, libxine2-misc-plugins, libxine2-plugins, libxine2-x, libxine2-vdr, libxine2-enigma
 Description: the xine video/media player library, binary files
  This is the xine media player library (libxine).
  .
diff -ruN o/debian/libxine2-dev.install pc/debian/libxine2-dev.install
--- o/debian/libxine2-dev.install	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/libxine2-dev.install	2024-07-21 14:42:55.838005503 +0300
@@ -1,11 +1,9 @@
 usr/bin/xine-config
 usr/include
 usr/lib/libxine.la
+usr/lib/libxine-interface.la
 usr/lib/libxine*.so
 usr/lib/pkgconfig/libxine.pc
-#usr/lib/xine/plugins/*/*.la
-#usr/lib/xine/plugins/*/post/*.la
-#usr/lib/xine/plugins/*/vidix/*.la
 usr/share/aclocal/xine.m4
 usr/share/man/man1/xine-config.1
 ../dh_xine				usr/bin
diff -ruN o/debian/libxine2-doc.docs pc/debian/libxine2-doc.docs
--- o/debian/libxine2-doc.docs	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/libxine2-doc.docs	2024-07-21 14:42:55.838005503 +0300
@@ -1,4 +1,3 @@
-debian/tmp/usr/share/doc/libxine2/faq/*
 debian/tmp/usr/share/doc/libxine2/README_xxmc.html
 debian/tmp/usr/share/doc/libxine2/README
 debian/tmp/usr/share/doc/libxine2/faq.*
diff -ruN o/debian/libxine2.install pc/debian/libxine2.install
--- o/debian/libxine2.install	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/libxine2.install	2024-07-21 14:42:55.838005503 +0300
@@ -2,9 +2,10 @@
 usr/lib/libxine*.so.*
 usr/lib/xine/plugins/*/post/*.so
 usr/lib/xine/plugins/*/*.so
-#usr/lib/xine/plugins/*/vidix/*.so
+usr/lib/xine/plugins/*/mime.types
 usr/share/locale
 usr/share/xine-lib
-usr/share/doc/libxine2/hackersguide/*
+usr/share/doc/libxine2/*
 usr/share/bug/libxine2/presubj
 usr/share/man/man1/xine-list*.1
+#usr/lib/xine/plugins/*/vidix/*.so
diff -ruN o/debian/rules pc/debian/rules
--- o/debian/rules	2023-07-10 19:46:14.000000000 +0300
+++ pc/debian/rules	2024-07-21 14:42:55.838005503 +0300
@@ -69,8 +69,9 @@
 	--prefix=/usr \
 	--with-freetype \
 	--with-wavpack \
-	--enable-ipv6 \
 	--with-external-dvdnav \
+	--enable-directfb \
+	--enable-dvb \
 	$(DEB_BUILD_CONFIG_OPTIONS)
 
 configure: configure-stamp
@@ -135,7 +136,7 @@
 	mv debian/tmp/usr/share/doc/xine-lib debian/tmp/usr/share/doc/libxine${major}
 #	build libxine${major} package by moving files from libxine-dev
 	dh_install --sourcedir=debian/tmp --list-missing
-	dh_installman -plibxine-dev debian/dh_xine.1
+	dh_installman -plibxine2-dev debian/dh_xine.1
 	dh_installdocs
 	dh_installchangelogs -k ChangeLog
 	dh_link
diff -ruN o/include/xine/metronom.h pc/include/xine/metronom.h
--- o/include/xine/metronom.h	2023-07-10 19:46:14.000000000 +0300
+++ pc/include/xine/metronom.h	2024-07-21 14:42:55.838005503 +0300
@@ -191,6 +191,11 @@
 #define METRONOM_VDR_TRICK_PTS    11
 #define METRONOM_NO_LOCK          0x8000
 
+/* Nasty input_enigma helper. Inserts an immediate absolute discontinuity,
+ * old style without pts reorder fix. */
+#define METRONOM_ENIGMA_TRICK_PTS    12
+#define METRONOM_NO_LOCK          0x8000
+
 typedef void xine_speed_change_cb_t (void *user_data, int new_speed);
 
 metronom_t *_x_metronom_init (int have_video, int have_audio, xine_t *xine) XINE_MALLOC XINE_PROTECTED;
diff -ruN o/include/xine/osd.h pc/include/xine/osd.h
--- o/include/xine/osd.h	2023-07-10 19:46:14.000000000 +0300
+++ pc/include/xine/osd.h	2024-07-21 14:42:55.839005487 +0300
@@ -216,6 +216,7 @@
    * overlay is blended at output (screen) resolution.
    */
   int (*show_unscaled) (osd_object_t *osd, int64_t vpts );
+  int (*show_scaled) (osd_object_t *osd, int64_t vpts );
 
   /*
    * see xine.h for defined XINE_OSD_CAP_ values.
diff -ruN o/include/xine/video_out.h pc/include/xine/video_out.h
--- o/include/xine/video_out.h	2023-07-10 19:46:14.000000000 +0300
+++ pc/include/xine/video_out.h	2024-07-21 14:42:55.839005487 +0300
@@ -287,6 +287,9 @@
 #define VO_PROP_CAPS2                 30 /* read-only. second capability flags, see below. */
 #define VO_PROP_TRANSFORM             31 /* XINE_VO_TRANSFORM_* */
 #define VO_NUM_PROPERTIES             32
+#define VO_PROP_LAST_PTS              33
+#define VO_PROP_DEINTERLACE_SD        34
+#define VO_PROP_DEINTERLACE_HD        35
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
diff -ruN o/include/xine/xineintl.h pc/include/xine/xineintl.h
--- o/include/xine/xineintl.h	2023-07-10 19:46:14.000000000 +0300
+++ pc/include/xine/xineintl.h	2024-07-21 14:42:55.839005487 +0300
@@ -27,6 +27,9 @@
 
 #include <locale.h>
 
+//#define ENABLE_NLS
+//#define XINE_TEXTDOMAIN "libxine2"
+
 #ifdef ENABLE_NLS
 #    include <libintl.h>
 #    define _(String) dgettext (XINE_TEXTDOMAIN, String)
diff -ruN o/include/xine.h pc/include/xine.h
--- o/include/xine.h	2023-07-10 19:46:14.000000000 +0300
+++ pc/include/xine.h	2024-07-21 14:42:55.839005487 +0300
@@ -1863,6 +1863,7 @@
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
 #define XINE_EVENT_NBC_STATS             15 /* nbc buffer status */
+#define XINE_EVENT_FRAMERATE_CHANGE      16
 
 
 /* input events coming from frontend */
@@ -1950,10 +1951,22 @@
 #define XINE_EVENT_VDR_TRICKSPEEDMODE   353
 #define XINE_EVENT_VDR_PLUGINSTARTED    354
 #define XINE_EVENT_VDR_DISCONTINUITY    355
+/* some space for further ENIGMA keys */
+#define XINE_EVENT_ENIGMA_SETVIDEOWINDOW   393
+#define XINE_EVENT_ENIGMA_FRAMESIZECHANGED 394
+#define XINE_EVENT_ENIGMA_SELECTAUDIO      395
+#define XINE_EVENT_ENIGMA_TRICKSPEEDMODE   396
+#define XINE_EVENT_ENIGMA_PLUGINSTARTED    397
+#define XINE_EVENT_ENIGMA_DISCONTINUITY    398
 
 /* events generated from post plugins */
 #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
 
+#define XINE_EVENT_SET_VIDEO_STREAMTYPE 501
+#define XINE_EVENT_SET_AUDIO_STREAMTYPE 502
+#define XINE_EVENT_SET_PVR_MODE         503
+
+
 /*
  * xine event struct
  */
@@ -1987,6 +2000,11 @@
   char                str[256]; /* might be longer */
 } xine_ui_data_t;
 
+typedef struct {
+  int                 pid;
+  int                 streamtype;
+} xine_streamtype_data_t;
+
 /*
  * Send messages to UI. used mostly to report errors.
  */
@@ -2065,6 +2083,10 @@
   int                 type;         /* 0=buffer put, 1=buffer get */
 } xine_nbc_stats_data_t;
 
+typedef struct {
+  int64_t             framerate;
+} xine_framerate_data_t;
+
 /*
  * mrl reference data is sent by demuxers when a reference stream is found.
  * this stream just contains pointers (urls) to the real data, which are
@@ -2370,6 +2392,7 @@
 void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
 void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_scaled   (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 /* empty drawing area */
 void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
diff -ruN o/m4/input.m4 pc/m4/input.m4
--- o/m4/input.m4	2023-07-10 19:46:14.000000000 +0300
+++ pc/m4/input.m4	2024-07-21 14:42:55.839005487 +0300
@@ -20,6 +20,7 @@
     default_enable_vcd=yes
     default_enable_vcdo=no
     default_enable_vdr=yes
+    default_enable_enigma=yes
     default_enable_bluray=yes
     default_enable_avformat=yes
     default_enable_sftp=yes
@@ -35,6 +36,7 @@
             default_enable_gnomevfs=no
             default_enable_samba=no
             default_enable_vdr=no
+            default_enable_enigma=no
             ;;
         darwin*)
             default_enable_gnomevfs=no
@@ -208,6 +210,10 @@
     XINE_ARG_ENABLE([vdr], [Enable support for the VDR plugin (default: enabled)])
     AM_CONDITIONAL([ENABLE_VDR], [test x"$enable_vdr" != x"no"])
 
+    dnl enigma
+    XINE_ARG_ENABLE([enigma], [Enable support for the ENIGMA plugin (default: enabled)])
+    AM_CONDITIONAL([ENABLE_ENIGMA], [test x"$enable_enigma" != x"no"])
+
     dnl bluray
     XINE_ARG_ENABLE([bluray], [Enable BluRay support])
     if test "x$enable_bluray" != "xno"; then
diff -ruN o/m4/summary.m4 pc/m4/summary.m4
--- o/m4/summary.m4	2023-07-10 19:46:14.000000000 +0300
+++ pc/m4/summary.m4	2024-07-21 14:42:55.840005471 +0300
@@ -54,6 +54,7 @@
     dis=""
     echo "  * Misc:"
     test x"$enable_vdr" != x"no"     && echo "   - vdr"       || dis="$dis vdr"
+    test x"$enable_enigma" != x"no"  && echo "   - enigma"    || dis="$dis enigma"
     test x"$have_gnomevfs" = x"yes"  && echo "   - gnome-vfs" || dis="$dis gnome-vfs"
     test x"$enable_ffmpeg" != x"no" -a x"$have_avformat" = x"yes" && echo "   - avio (libavformat)" || dis="$dis avio"
     echo "   - test"
@@ -201,6 +202,7 @@
     echo "   - unsharp         - tvtime"
     test x"$enable_postproc" != x"no" && echo "   - postproc"  || dis="$dis postproc"
     test x"$enable_vdr" != x"no"      && echo "   - vdr"       || dis="$dis vdr"
+    test x"$enable_enigma" != x"no"   && echo "   - enigma"    || dis="$dis enigma"
     echo "  * SFX:"
     echo "   - goom            - oscope"
     echo "   - fftscope        - mosaico"
diff -ruN o/src/demuxers/demux_mpeg_pes.c pc/src/demuxers/demux_mpeg_pes.c
--- o/src/demuxers/demux_mpeg_pes.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/demuxers/demux_mpeg_pes.c	2024-07-21 14:42:55.840005471 +0300
@@ -71,6 +71,7 @@
 
   input_plugin_t       *input;
   int                   is_vdr;
+  int                   is_enigma;
 
   int                   status;
 
@@ -493,6 +494,22 @@
 #endif
 }
 
+static void demux_mpeg_pes_enigma_seek_0 (demux_mpeg_pes_t *this, int n) {
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "demux_mpeg_pes: enigma sync point #%d.\n", n);
+  this->last_cell_time = 0;
+  this->send_newpts = 1;
+  this->buf_flag_seek = 0;
+  this->nav_last_end_pts = this->nav_last_start_pts = 0;
+  this->status   = DEMUX_OK ;
+  this->last_pts[0]   = 0;
+  this->last_pts[1]   = 0;
+#ifdef PTS_BOUNCE
+  this->apts = this->bpts = 0;
+  this->bounce_left = 0;
+#endif
+}
+
 static int32_t parse_padding_stream(demux_mpeg_pes_t *this, uint8_t *p, buf_element_t *buf) {
   /* Just skip padding. */
   int todo = 6 + this->packet_len;
@@ -503,6 +520,9 @@
   if (this->is_vdr && (buf->content[4] == 0xff))
     demux_mpeg_pes_vdr_seek_0 (this, buf->content[5]);
 
+  if (this->is_enigma && (buf->content[4] == 0xff))
+    demux_mpeg_pes_enigma_seek_0 (this, buf->content[5]);
+
   while (done < todo)
   {
     /* Handle Jumbo frames from VDR. */
@@ -1773,8 +1793,11 @@
   this->status = DEMUX_FINISHED;
 
   this->is_vdr = 0;
+  this->is_enigma = 0;
   if (input->input_class->identifier && !strcmp (input->input_class->identifier, "VDR"))
     this->is_vdr = 1;
+  if (input->input_class->identifier && !strcmp (input->input_class->identifier, "ENIGMA"))
+    this->is_enigma = 1;
 
   /* Don't start demuxing stream until we see a program_stream_pack_header */
   /* We need to system header in order to identify is the stream is mpeg1 or mpeg2. */
diff -ruN o/src/demuxers/demux_ts.c pc/src/demuxers/demux_ts.c
--- o/src/demuxers/demux_ts.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/demuxers/demux_ts.c	2024-07-21 14:42:55.840005471 +0300
@@ -161,7 +161,7 @@
 #define LOG
 */
 #define LOG_DYNAMIC_PMT
-#define DUMP_VIDEO_HEADS
+//#define DUMP_VIDEO_HEADS /* ENIGMA_FIFO does not contain video heads */
 
 #ifdef DUMP_VIDEO_HEADS
 #  include <stdio.h>
@@ -595,6 +595,7 @@
   off_t        tbre_bytes, tbre_lastpos;
   int64_t      tbre_time, tbre_lasttime;
   unsigned int tbre_mode, tbre_pid;
+  int          pvr_mode; // Default equal is '0', then pids receive from E2
 
 #ifdef DUMP_VIDEO_HEADS
   FILE *vhdfile;
@@ -2865,6 +2866,7 @@
 /* 0 (go on), 1 (recheck), 2 (stop) */
 static int demux_ts_parse_pat_pmt_packet (demux_ts_t*this) {
 
+ if (this->pvr_mode == 1) {
   const uint8_t *originalPkt;
   uint32_t       tsp_head;
   uint32_t       pid;
@@ -2941,10 +2943,12 @@
     return 1;
   }
 
+ }
   return 0;
 }
 
 static void demux_ts_scan_pat_pmt (demux_ts_t *this) {
+ if (this->pvr_mode == 1) {
   unsigned int max;
 
   if ((this->videoPid != INVALID_PID) || (this->audio_tracks_count > 0))
@@ -2976,6 +2980,7 @@
     this->buf_size = 0;
 #endif
   }
+ }
 }
 
 
@@ -2985,6 +2990,7 @@
 
 static void demux_ts_event_handler (demux_ts_t *this) {
   xine_event_t *event = NULL;
+  int mi;
 
   while ((event = xine_event_next (this->event_queue, event))) {
 
@@ -2994,6 +3000,7 @@
       /* flush all streams */
       demux_ts_flush(this);
       /* fall thru */
+      break;
 
     case XINE_EVENT_PIDS_CHANGE:
 
@@ -3002,6 +3009,36 @@
       _x_demux_control_start (this->stream);
       break;
 
+    case XINE_EVENT_SET_VIDEO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_VIDEO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_VIDEO_BASE, data->streamtype);
+        if (mi >= 0) {
+          this->videoPid = data->pid;
+          this->videoMedia = mi;
+        }
+      }
+      break;
+
+    case XINE_EVENT_SET_AUDIO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_AUDIO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_AUDIO_BASE, data->streamtype);
+      }
+      break;
+
+    case XINE_EVENT_SET_PVR_MODE:
+      printf("RECEIVED XINE_EVENT_SET_PVR_MODE\n");
+
+      this->pvr_mode = 1;
+      break;
+
     }
   }
 }
@@ -3560,6 +3597,9 @@
   this->pkt_size   = PKT_SIZE + this->pkt_offset;
 #endif
 
+  /* PVR_MODE, default is LIVE_TV, pids receive from E2 */
+  this->pvr_mode = 0;
+
 #ifdef DUMP_VIDEO_HEADS
   this->vhdfile = fopen ("video_heads.log", "rb+");
 #endif
diff -ruN o/src/e2pc/combined_enigma.c pc/src/e2pc/combined_enigma.c
--- o/src/e2pc/combined_enigma.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/combined_enigma.c	2024-07-21 14:42:55.840005471 +0300
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2000-2019 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * plugins for ENIGMA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+static const post_info_t enigma_video_special_info = { XINE_POST_TYPE_VIDEO_FILTER };
+static const post_info_t enigma_audio_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
+
+/* exported plugin catalog entry */
+const plugin_info_t xine_plugin_info[] EXPORTED =
+{
+  /* type       , API, "name"        , version          , special_info              , init_function */
+  { PLUGIN_INPUT,  18, "ENIGMA"      , XINE_VERSION_CODE, NULL                      , &enigma_input_init_plugin },
+  { PLUGIN_POST ,  10, "enigma"      , XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_video", XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_audio", XINE_VERSION_CODE, &enigma_audio_special_info, &enigma_audio_init_plugin },
+  { PLUGIN_NONE ,   0, NULL          , 0                , NULL                      , NULL }
+};
+
diff -ruN o/src/e2pc/combined_enigma.h pc/src/e2pc/combined_enigma.h
--- o/src/e2pc/combined_enigma.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/combined_enigma.h	2024-07-21 14:42:55.840005471 +0300
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2000-2018 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifndef __COMBINED_ENIGMA_H
+#define __COMBINED_ENIGMA_H
+
+
+
+typedef struct enigma_set_video_window_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+} enigma_set_video_window_data_t;
+
+
+
+typedef struct enigma_frame_size_changed_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  double r;
+
+} enigma_frame_size_changed_data_t;
+
+
+
+typedef struct enigma_select_audio_data_s {
+  uint8_t channels;
+
+} enigma_select_audio_data_t;
+
+
+
+inline static int enigma_is_enigma_stream(xine_stream_t *stream)
+{
+  if (!stream
+      || !stream->input_plugin
+      || !stream->input_plugin->input_class)
+  {
+    return 0;
+  }
+
+  if (stream->input_plugin->input_class->identifier &&
+      0 == strcmp(stream->input_plugin->input_class->identifier, "ENIGMA"))
+    return 1;
+
+  return 0;
+}
+
+
+
+/* plugin class initialization function */
+void *enigma_input_init_plugin(xine_t *xine, const void *data);
+void *enigma_video_init_plugin(xine_t *xine, const void *data);
+void *enigma_audio_init_plugin(xine_t *xine, const void *data);
+
+
+
+#endif /* __COMBINED_ENIGMA_H */
+
diff -ruN o/src/e2pc/input_enigma.c pc/src/e2pc/input_enigma.c
--- o/src/e2pc/input_enigma.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/input_enigma.c	2024-07-21 14:42:55.841005455 +0300
@@ -0,0 +1,859 @@
+/*
+ * Copyright (C) 2003-2021 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/* NOTE: This will bend the xine engine into a certain direction (just to avoid the
+ * term "misuse"). Demux keeps running all the time. Its the enigma server that
+ * performs seeks, stream switches, still frames, trick play frames etc.
+ * It then muxes the result down the line sequentially. For the demuxer, most stuff
+ * looks like ordinary absolute discontinuities. We need to watch the control
+ * messages coming through a side channel, and inject apropriate xine engine calls
+ * manually. In reverse, we listen to xine events, and send back enigma keys.
+ * "Trick play" is turned on and off by server. When on, xine shall just play all
+ * frames as if they had perfectly consecutive time stamps. We still need to register
+ * first discontinuity early because server will wait for it, and video decoder may
+ * delay it -> freeze.
+ * Issue #2: xine engine now uses a more efficient buffering scheme. Audio fifo
+ * default now is 700*2k with soft start vs 230*8k fixed. This is needed to support
+ * modern fragment streaming protocols. It also helps live DVB radio, and it speeds
+ * up seeking. However, enigma seems to freeze from it sometimes. We work around it
+ * by using fifo->buffer_pool_size_alloc (fifo, need), and by registering a dummy
+ * alloc callback that disables file_buf_ctrl soft start.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <pthread.h>
+
+#define LOG_MODULE "input_enigma"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+#include <xine/input_plugin.h>
+
+#include "combined_enigma.h"
+#include "net_buf_ctrl.h" /* ? */
+
+// xvdr
+#include <sys/time.h>
+
+#define ENIGMA_ABS_FIFO_DIR     "/tmp"
+#define DEFAULT_PTS_START       150000
+#define BUFSIZE                 1024
+#define FILE_FLAGS O_RDONLY
+#define FIFO_PUT                0
+// xvdr
+#define XVDR_METRONOM_OPTION_BASE  0x1001
+#define XVDR_METRONOM_LAST_VO_PTS  (XVDR_METRONOM_OPTION_BASE)
+#define XVDR_METRONOM_TRICK_SPEED  (XVDR_METRONOM_OPTION_BASE + 1)
+#define XVDR_METRONOM_STILL_MODE   (XVDR_METRONOM_OPTION_BASE + 2)
+#define XVDR_METRONOM_ID           (XVDR_METRONOM_OPTION_BASE + 3)
+
+#define XVDR_METRONOM_LIVE_BUFFERING   (XVDR_METRONOM_OPTION_BASE + 4)
+#define XVDR_METRONOM_STREAM_START     (XVDR_METRONOM_OPTION_BASE + 5)
+
+typedef struct enigma_input_plugin_s enigma_input_plugin_t;
+
+  /* This is our relay metronom, built on top of the engine one.
+   * src/xine-engine/metronom.c uses a much more complex algorithm now.
+   * One goal is to avoid unnecessary waiting. Thus lets not wait
+   * ourselves here, and detect complete discontinuity pairs instead. */
+typedef struct {
+  metronom_t          metronom;
+  metronom_t         *stream_metronom;
+  enigma_input_plugin_t *input;
+  // xvdr
+  int     trickspeed;    /* current trick speed */
+  int     still_mode;
+  int64_t last_vo_pts;   /* last displayed video frame PTS */
+  int     wired;         /* true if currently wired to stream */
+
+  /* initial buffering in live mode */
+  uint8_t  buffering;      /* buffering active */
+  uint8_t  live_buffering; /* live buffering enabled */
+  uint8_t  stream_start;
+  int64_t  vid_pts;        /* last seen video pts */
+  int64_t  aud_pts;        /* last seen audio pts */
+  int64_t  disc_pts;       /* reported discontinuity pts */
+  uint64_t buffering_start_time;
+  uint64_t first_frame_seen_time;
+
+  pthread_mutex_t mutex;
+}
+enigma_metronom_t;
+
+typedef struct enigma_osd_s
+{
+  xine_osd_t *window;
+  uint8_t    *argb_buffer[ 2 ];
+  int         width;
+  int         height;
+}
+enigma_osd_t;
+
+typedef struct enigma_vpts_offset_s enigma_vpts_offset_t;
+
+struct enigma_vpts_offset_s
+{
+  enigma_vpts_offset_t *next;
+  int64_t            vpts;
+  int64_t            offset;
+};
+
+struct enigma_input_plugin_s {
+  input_plugin_t      input_plugin;
+  xine_stream_t      *stream;
+  int                 fh;
+  char               *mrl;
+  off_t               curpos;
+  char                seek_buf[BUFSIZE];
+  xine_t             *xine;
+  int                 last_disc_type;
+
+  uint8_t             trick_speed_mode;
+  uint8_t             trick_speed_mode_blocked;
+  pthread_mutex_t     trick_speed_mode_lock;
+  pthread_cond_t      trick_speed_mode_cond;
+
+  pthread_t           metronom_thread;
+  pthread_mutex_t     metronom_thread_lock;
+  int64_t             metronom_thread_request;
+  int                 metronom_thread_reply;
+  pthread_cond_t      metronom_thread_request_cond;
+  pthread_cond_t      metronom_thread_reply_cond;
+  pthread_mutex_t     metronom_thread_call_lock;
+
+  uint8_t             find_sync_point;
+  pthread_mutex_t     find_sync_point_lock;
+
+  enigma_metronom_t      metronom;
+
+  enigma_vpts_offset_t  *vpts_offset_queue;
+  enigma_vpts_offset_t  *vpts_offset_queue_tail;
+  pthread_mutex_t     vpts_offset_queue_lock;
+  pthread_cond_t      vpts_offset_queue_changed_cond;
+  int                 vpts_offset_queue_changes;
+
+  // xvdr
+  int     trickspeed;    // current trick speed
+  int     still_mode;
+  int64_t last_vo_pts;   // last displayed video frame PTS
+  int     wired;         // true if currently wired to stream
+};
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+} enigma_input_class_t;
+
+// xvdr
+static uint64_t time_ms(void)
+{
+  struct timeval t;
+#ifdef XINEUTILS_H
+  if (xine_monotonic_clock(&t, NULL) == 0)
+#else
+  if (gettimeofday(&t, NULL) == 0)
+#endif
+     return ((uint64_t)t.tv_sec) * 1000ULL + t.tv_usec / 1000ULL;
+  return 0;
+}
+
+static uint64_t elapsed(uint64_t t)
+{
+  return time_ms() - t;
+}
+
+static int warnings = 0;
+
+static int64_t absdiff(int64_t a, int64_t b) { int64_t diff = a-b; if (diff<0) diff = -diff; return diff; }
+static int64_t min64(int64_t a, int64_t b) { return a < b ? a : b; }
+
+static void check_buffering_done(enigma_metronom_t *this)
+{
+  /* both audio and video timestamps seen ? */
+  if (this->vid_pts && this->aud_pts) {
+    int64_t da = this->aud_pts - this->disc_pts;
+    int64_t dv = this->vid_pts - this->disc_pts;
+    int64_t d_min = min64(da, dv);
+    printf("  stream A-V diff %d ms", (int)(this->vid_pts - this->aud_pts)/90);
+    printf("  reported stream start at pts %"PRId64, this->disc_pts);
+    printf("  output fifo end at: audio %"PRId64" video %"PRId64, this->aud_pts, this->vid_pts);
+    printf("  dA %"PRId64" dV %"PRId64, da, dv);
+    if (d_min < 0 && d_min > -10*90000) {
+      printf("  *** output is late %"PRId64" ticks (%"PRId64" ms) ***", d_min, -d_min/90);
+    }
+    this->buffering = 0;
+    this->stream_start = 0;
+    return;
+  }
+
+  if (this->first_frame_seen_time) {
+    int64_t ms_since_first_frame = elapsed(this->first_frame_seen_time);
+
+    if (ms_since_first_frame > 1000) {
+
+      this->stream_start = 0;
+
+      /* abort buffering if no audio */
+      if (this->vid_pts && !this->aud_pts) {
+        printf("buffering stopped: NO AUDIO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+        return;
+      }
+
+      /* abort buffering if no video */
+      if (!this->vid_pts && this->aud_pts) {
+        printf("buffering stopped: NO VIDEO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+        return;
+      }
+    }
+  }
+}
+
+static void got_video_frame(metronom_t *self, vo_frame_t *frame)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  int64_t          pts  = frame->pts;
+
+  if (this->still_mode) {
+    printf("Still frame, type %d", frame->picture_coding_type);
+    frame->pts       = 0;
+  }
+
+  if (this->trickspeed) {
+    frame->pts       = 0;
+    frame->duration *= 12; /* GOP */
+  }
+
+  /* initial buffering */
+  pthread_mutex_lock(&this->mutex);
+  if (this->buffering && !frame->bad_frame) {
+
+    /* track video pts */
+    if (pts) {
+      if (this->vid_pts && (absdiff(this->vid_pts, pts) > 5*90000)) {
+        printf("buffering: video jump resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (this->vid_pts && this->aud_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (!this->vid_pts) {
+        printf("got video pts, frame type %d (@%d ms)", frame->picture_coding_type, (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms(); 
+      }
+      this->vid_pts = pts;
+    }
+
+    /* some logging */
+    if (!pts) {
+      printf("got video, pts 0, buffering, frame type %d, bad_frame %d", frame->picture_coding_type, frame->bad_frame);
+    }
+    if (pts && !frame->pts) {
+      printf("*** ERROR: hiding video pts while buffering ***");
+    }
+
+    check_buffering_done(this);
+  }
+
+  pthread_mutex_unlock(&this->mutex);
+
+  this->stream_metronom->got_video_frame (this->stream_metronom, frame);
+
+  frame->pts = pts;
+}
+
+static int64_t got_audio_samples(metronom_t *self, int64_t pts, int nsamples)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  pthread_mutex_lock(&this->mutex);
+
+  /* initial buffering */
+  if (this->buffering) {
+
+    /* track audio pts */
+    if (pts) {
+      if (this->aud_pts && (this->aud_pts > pts || absdiff(pts, this->aud_pts) > 5*90000)) {
+        printf("audio jump resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (this->aud_pts && this->vid_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (!this->aud_pts) {
+        printf("got audio pts (@%d ms)", (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms();
+      }
+      this->aud_pts = pts;
+    }
+
+    /* some logging */
+    if (!pts && !this->aud_pts) {
+      printf("got audio, pts 0, buffering");
+    }
+
+    check_buffering_done(this);
+  }
+
+  pthread_mutex_unlock(&this->mutex);
+
+  return this->stream_metronom->got_audio_samples (this->stream_metronom, pts, nsamples);
+}
+
+static int64_t got_spu_packet(metronom_t *self, int64_t pts)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  return this->stream_metronom->got_spu_packet(this->stream_metronom, pts);
+}
+
+static void start_buffering(enigma_metronom_t *this, int64_t disc_off)
+{
+  if (this->live_buffering && this->stream_start && disc_off) {
+    if (!this->buffering) {
+      printf("live mode buffering started (@%d ms)", (int)elapsed(this->buffering_start_time));
+
+      this->aud_pts  = 0;
+      this->vid_pts  = 0;
+      this->disc_pts = disc_off;
+
+      this->first_frame_seen_time = 0;
+
+      this->buffering = 1;
+    }
+  } else {
+    if (this->buffering) {
+      printf("live mode buffering aborted (@%d ms)", (int)elapsed(this->buffering_start_time));
+      this->buffering = 0;
+    }
+  }
+}
+
+static void handle_audio_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_audio_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void handle_video_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_video_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void set_audio_rate(metronom_t *self, int64_t pts_per_smpls)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_audio_rate(this->stream_metronom, pts_per_smpls);
+}
+
+static void set_option(metronom_t *self, int option, int64_t value)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    if (value > 0) {
+      pthread_mutex_lock(&this->mutex);
+      this->last_vo_pts = value;
+      pthread_mutex_unlock(&this->mutex);
+    }
+    return;
+  }
+
+  if (option == XVDR_METRONOM_LIVE_BUFFERING) {
+    pthread_mutex_lock(&this->mutex);
+    this->live_buffering = value;
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STREAM_START) {
+    pthread_mutex_lock(&this->mutex);
+    this->stream_start = 1;
+    this->buffering_start_time = time_ms();
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    this->trickspeed = value;
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    this->still_mode = value;
+    return;
+  }
+
+  this->stream_metronom->set_option(this->stream_metronom, option, value);
+}
+
+static int64_t get_option(metronom_t *self, int option)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    int64_t pts;
+    pthread_mutex_lock(&this->mutex);
+    pts = this->last_vo_pts;
+    pthread_mutex_unlock(&this->mutex);
+    return pts;
+  }
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    return this->trickspeed;
+  }
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    return this->still_mode;
+  }
+  if (option == XVDR_METRONOM_ID) {
+    return XVDR_METRONOM_ID;
+  }
+
+  return this->stream_metronom->get_option(this->stream_metronom, option);
+}
+
+static void set_master(metronom_t *self, metronom_t *master)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_master(this->stream_metronom, master);
+}
+
+static void metronom_exit(metronom_t *self)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  _x_abort();
+}
+
+static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{
+  off_t ret;
+
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+
+    break;
+  }
+
+  return ret;
+}
+
+static off_t enigma_plugin_read (input_plugin_t *this_gen,
+				void *buf_gen, off_t len) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+  uint8_t *buf = (uint8_t *)buf_gen;
+  off_t n, total = 0;
+#ifdef LOG_READ
+  lprintf ("reading %lld bytes...\n", len);
+#endif
+
+  if( len > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = enigma_read_abort (this->stream, this->fh, (char *)&buf[total], len-total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); // 200 * 50ms
+#ifdef LOG_READ
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n", n, total, len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+
+  if (this->find_sync_point
+    && total == 6)
+  {
+    pthread_mutex_lock(&this->find_sync_point_lock);
+
+    while (this->find_sync_point
+      && total == 6
+      && buf[0] == 0x00
+      && buf[1] == 0x00
+      && buf[2] == 0x01)
+    {
+      int l, sp;
+
+      if (buf[3] == 0xbe
+        && buf[4] == 0xff)
+      {
+        if (buf[5] == this->find_sync_point)
+        {
+          this->find_sync_point = 0;
+          break;
+        }
+      }
+
+      if ((buf[3] & 0xf0) != 0xe0
+        && (buf[3] & 0xe0) != 0xc0
+        && buf[3] != 0xbd
+        && buf[3] != 0xbe)
+      {
+        break;
+      }
+
+      l = buf[4] * 256 + buf[5];
+      if (l <= 0)
+         break;
+
+      sp = this->find_sync_point;
+      this->find_sync_point = 0;
+      this_gen->seek(this_gen, l, SEEK_CUR);
+      total = this_gen->read(this_gen, buf, 6);
+      this->find_sync_point = sp;
+    }
+
+    pthread_mutex_unlock(&this->find_sync_point_lock);
+  }
+
+  return total;
+
+}
+
+static buf_element_t *enigma_plugin_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo,
+					off_t todo) {
+
+  off_t                 total_bytes;
+  buf_element_t         *buf = fifo->buffer_pool_alloc (fifo);
+
+  if (todo > buf->max_size)
+    todo = buf->max_size;
+  if (todo < 0) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = enigma_plugin_read (this_gen, (char*)buf->content, todo);
+
+  if (total_bytes != todo) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t enigma_plugin_get_current_pos(input_plugin_t *this_gen);
+
+static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("seek %"PRId64" offset, %d origin...\n", offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0)) {
+
+    for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+      if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET) {
+
+    if (offset < this->curpos) {
+        xprintf (this->xine, XINE_VERBOSITY_LOG,
+                 _("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n"),
+                 (intmax_t)this->curpos, (intmax_t)offset);
+        printf ("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n",
+                 (intmax_t)this->curpos, (intmax_t)offset);
+
+    } else {
+      offset -= this->curpos;
+
+      for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+        if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+          return this->curpos;
+      }
+
+      this_gen->read (this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t enigma_plugin_get_length(input_plugin_t *this_gen) {
+  return 0;
+}
+
+static uint32_t enigma_plugin_get_capabilities(input_plugin_t *this_gen) {
+
+  return INPUT_CAP_PREVIEW;
+}
+
+static uint32_t enigma_plugin_get_blocksize(input_plugin_t *this_gen) {
+
+  return 0;
+}
+
+static off_t enigma_plugin_get_current_pos (input_plugin_t *this_gen){
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->curpos;
+}
+
+static const char* enigma_plugin_get_mrl (input_plugin_t *this_gen) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->mrl;
+}
+
+static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  pthread_mutex_destroy(&this->metronom.mutex);
+
+  pthread_mutex_destroy(&this->find_sync_point_lock); // need
+
+
+  if (this->fh != -1)
+    close(this->fh);
+
+  free (this->mrl);
+
+  this->stream->metronom = this->metronom.stream_metronom;
+  this->metronom.stream_metronom = 0;
+
+  free (this);
+}
+
+static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
+					void *data, int data_type) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+  (void)this; //Add from 
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    /* just fake what mpeg_pes demuxer expects */
+    memcpy (data, "\x00\x00\x01\xe0\x00\x03\x80\x00\x00", 9);
+    return 9;
+  case INPUT_OPTIONAL_DATA_DEMUXER:
+    {
+      char **tmp = (char**)data;
+      *tmp = "mpeg-ts";
+    }
+    return 0;
+  }
+
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int enigma_plugin_open (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1) {
+    char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
+    this->fh = open (filename, FILE_FLAGS);
+
+    printf("filename '%s'\n", filename);
+
+    if (this->fh == -1) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, _("enigma_fifo: failed to open '%s'\n"), filename);
+      printf ("enigma_fifo: failed to open '%s'\n", filename);
+      return 0;
+    }
+
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this->curpos          = 0;
+
+  return 1;
+}
+
+static input_plugin_t *enigma_class_get_instance (input_class_t *class_gen,
+						xine_stream_t *stream, const char *data) {
+
+  enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
+  enigma_input_plugin_t *this;
+  char                 *mrl = strdup(data);
+
+  if (!strncasecmp(mrl, "enigma:/", 8)) {
+    lprintf("Enigma plugin\n");
+  } else {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this       = calloc(1, sizeof(enigma_input_plugin_t));
+
+  this->stream = stream;
+  this->curpos = 0;
+  this->mrl    = mrl;
+  this->fh     = -1;
+  this->xine   = class->xine;
+
+  this->input_plugin.open              = enigma_plugin_open;
+  this->input_plugin.get_capabilities  = enigma_plugin_get_capabilities;
+  this->input_plugin.read              = enigma_plugin_read;
+  this->input_plugin.read_block        = enigma_plugin_read_block;
+  this->input_plugin.seek              = enigma_plugin_seek;
+  this->input_plugin.get_current_pos   = enigma_plugin_get_current_pos;
+  this->input_plugin.get_length        = enigma_plugin_get_length;
+  this->input_plugin.get_blocksize     = enigma_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = enigma_plugin_get_mrl;
+  this->input_plugin.dispose           = enigma_plugin_dispose;
+  this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
+  this->input_plugin.input_class       = class_gen;
+
+  pthread_mutex_init(&this->find_sync_point_lock, 0);
+
+  this->metronom.input = this;
+
+  // xvdr
+  this->metronom.metronom.set_audio_rate             = set_audio_rate;
+  this->metronom.metronom.got_video_frame            = got_video_frame;
+  this->metronom.metronom.got_audio_samples          = got_audio_samples;
+  this->metronom.metronom.got_spu_packet             = got_spu_packet;
+  this->metronom.metronom.handle_audio_discontinuity = handle_audio_discontinuity;
+  this->metronom.metronom.handle_video_discontinuity = handle_video_discontinuity;
+  this->metronom.metronom.set_option                 = set_option;
+  this->metronom.metronom.get_option                 = get_option;
+  this->metronom.metronom.set_master                 = set_master;
+  this->metronom.metronom.exit                       = metronom_exit;
+
+  pthread_mutex_init(&this->metronom.mutex, NULL);
+
+  this->metronom.stream_metronom = stream->metronom;
+  stream->metronom = &this->metronom.metronom;
+
+  return &this->input_plugin;
+}
+
+void *init_class (xine_t *xine, void *data) {
+
+  enigma_input_class_t  *this;
+
+  this = calloc(1, sizeof (enigma_input_class_t));
+
+  this->xine   = xine;
+
+  this->input_class.get_instance       = enigma_class_get_instance;
+  this->input_class.identifier         = "ENIGMA";
+  this->input_class.description        = N_("ENIGMA2PC display device plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = default_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
+
+/*
+ * enigma input plugin class stuff
+ */
+static const char * const *enigma_class_get_autoplay_list(input_class_t *this_gen,
+                                          int *num_files)
+{
+  static const char * const mrls[] = {"enigma:/" ENIGMA_ABS_FIFO_DIR "/stream#demux:mpeg_pes", NULL};
+
+  (void)this_gen;
+  *num_files = 1;
+  return mrls;
+}
+
+void *enigma_input_init_plugin(xine_t *xine, const void *data)
+{
+  lprintf("init_class\n");
+  static const input_class_t this = {
+    .get_instance      = enigma_class_get_instance,
+    .identifier        = "ENIGMA",
+    .description       = N_("ENIGMA display device plugin"),
+    .get_dir           = NULL,
+    .get_autoplay_list = enigma_class_get_autoplay_list,
+    .dispose           = NULL,
+    .eject_media       = NULL
+  };
+  (void)xine;
+  (void)data;
+  return (input_class_t *)&this;
+}
diff -ruN o/src/e2pc/Makefile.am pc/src/e2pc/Makefile.am
--- o/src/e2pc/Makefile.am	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/Makefile.am	2024-07-21 14:42:55.841005455 +0300
@@ -0,0 +1,13 @@
+include $(top_builddir)/misc/Makefile.plugins
+include $(top_srcdir)/misc/Makefile.common
+
+AM_CFLAGS  = $(DEFAULT_OCFLAGS) $(VISIBILITY_FLAG)
+AM_LDFLAGS = $(xineplug_ldflags)
+
+if ENABLE_ENIGMA
+xineplug_LTLIBRARIES = xineplug_enigma.la
+endif
+
+xineplug_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c post_enigma_video.c post_enigma_audio.c
+xineplug_enigma_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
+xineplug_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
diff -ruN o/src/e2pc/post_enigma_audio.c pc/src/e2pc/post_enigma_audio.c
--- o/src/e2pc/post_enigma_audio.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/post_enigma_audio.c	2024-07-21 14:42:55.841005455 +0300
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2000-2019 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * select audio channel plugin for ENIGMA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define LOG_MODULE "enigma_audio"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_audio_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  uint8_t audio_channels;
+  int num_channels;
+
+}
+enigma_audio_post_plugin_t;
+
+
+static void enigma_audio_select_audio(enigma_audio_post_plugin_t *this, uint8_t channels)
+{
+  this->audio_channels = channels;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_audio_dispose(post_plugin_t *this_gen);
+
+/* replaced ao_port functions */
+static int            enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                                          uint32_t bits, uint32_t rate, int mode);
+static void           enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream);
+
+
+
+void *enigma_audio_init_plugin(xine_t *xine, const void *data)
+{
+  post_class_t *class = calloc(1, sizeof (post_class_t));
+
+  (void)xine;
+  (void)data;
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_audio_open_plugin;
+  class->identifier      = "enigma_audio";
+  class->description     = N_("modifies every audio frame as requested by ENIGMA");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+				      xine_audio_port_t **audio_target,
+				      xine_video_port_t **video_target)
+{
+  enigma_audio_post_plugin_t *this = calloc(1, sizeof (enigma_audio_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_audio_port_t       *port;
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr open plugin\n");
+*/
+  if (!this || !audio_target || !audio_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  (void)class_gen;
+  (void)inputs;
+  (void)video_target;
+
+  _x_post_init(&this->post_plugin, 1, 0);
+  this->post_plugin.dispose = enigma_audio_dispose;
+
+  port = _x_post_intercept_audio_port(&this->post_plugin, audio_target[ 0 ], &input, &output);
+  port->new_port.open       = enigma_audio_port_open;
+  port->new_port.put_buffer = enigma_audio_port_put_buffer;
+
+  this->post_plugin.xine_post.audio_input[ 0 ] = &port->new_port;
+
+
+
+  this->audio_channels = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_audio_dispose(post_plugin_t *this_gen)
+{
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr dispose\n");
+*/
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+      xine_event_dispose_queue(this->event_queue);
+
+    free(this_gen);
+  }
+}
+
+static int enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                               uint32_t bits, uint32_t rate, int mode) {
+
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+
+  _x_post_rewire(&this->post_plugin);
+  _x_post_inc_usage(port);
+/*
+fprintf(stderr, "~~~~~~~~~~ vdr port open\n");
+*/
+  port->stream = stream;
+  port->bits = bits;
+  port->rate = rate;
+  port->mode = mode;
+
+  this->num_channels = _x_ao_mode2channels(mode);
+
+  return (port->original_port->open) (port->original_port, stream, bits, rate, mode );
+}
+
+
+static void enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream)
+{
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+  xine_event_t *event;
+/*
+fprintf(stderr, "~~~~~~ vdr_audio\n");
+*/
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->audio_channels = 0;
+  }
+
+  if (!this->enigma_stream
+      && enigma_is_enigma_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_ENIGMA_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 1; /* enigma_audio */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_ENIGMA_SELECTAUDIO)
+      {
+        enigma_select_audio_data_t *data = (enigma_select_audio_data_t *)event->data;
+
+        enigma_audio_select_audio(this, data->channels);
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  if (this->num_channels == 2
+      && this->audio_channels != 0
+      && this->audio_channels != 3)
+  {
+    audio_buffer_t *enigma_buf = port->original_port->get_buffer(port->original_port);
+    enigma_buf->num_frames = buf->num_frames;
+    enigma_buf->vpts = buf->vpts;
+    enigma_buf->frame_header_count = buf->frame_header_count;
+    enigma_buf->first_access_unit = buf->first_access_unit;
+    /* FIXME: The audio buffer should contain this info.
+     *        We should not have to get it from the open call.
+     */
+    enigma_buf->format.bits = buf->format.bits;
+    enigma_buf->format.rate = buf->format.rate;
+    enigma_buf->format.mode = buf->format.mode;
+    _x_extra_info_merge(enigma_buf->extra_info, buf->extra_info);
+
+    {
+      int step = buf->format.bits / 8;
+      uint8_t *src = (uint8_t *)buf->mem;
+      uint8_t *dst = (uint8_t *)enigma_buf->mem;
+
+      if (this->audio_channels == 2)
+        src += step;
+/*
+      fprintf(stderr, "~~~~~~~~~~ vdr port put buffer: channels: %d, %d\n"
+              , this->audio_channels
+              , buf->format.bits);
+*/
+      int i, k;
+      for (i = 0; i < buf->num_frames; i++)
+      {
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src -= step;
+
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src += step;
+      }
+    }
+
+    /* pass data to original port */
+    port->original_port->put_buffer(port->original_port, enigma_buf, stream);
+
+    /* free data from origial buffer */
+    buf->num_frames = 0; /* UNDOCUMENTED, but hey, it works! Force old audio_out buffer free. */
+  }
+
+  port->original_port->put_buffer(port->original_port, buf, stream);
+
+  return;
+}
diff -ruN o/src/e2pc/post_enigma_video.c pc/src/e2pc/post_enigma_video.c
--- o/src/e2pc/post_enigma_video.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/e2pc/post_enigma_video.c	2024-07-21 14:42:55.841005455 +0300
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 2000-2019 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * frame scaler plugin for ENIGMA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define LOG_MODULE "enigma_video"
+/*
+#define LOG
+#define LOG_VERBOSE
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_video_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  int8_t trick_speed_mode;
+  int8_t enabled;
+
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+  int32_t old_frame_left;
+  int32_t old_frame_top;
+  int32_t old_frame_width;
+  int32_t old_frame_height;
+  double  old_frame_ratio;
+
+}
+enigma_video_post_plugin_t;
+
+
+static void enigma_video_set_video_window(enigma_video_post_plugin_t *this, int32_t x, int32_t y, int32_t w, int32_t h, int32_t w_ref, int32_t h_ref)
+{
+  this->enabled = 0;
+
+  this->x     = x;
+  this->y     = y;
+  this->w     = w;
+  this->h     = h;
+  this->w_ref = w_ref;
+  this->h_ref = h_ref;
+
+  if (w != w_ref || h != h_ref)
+    this->enabled = 1;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_video_dispose(post_plugin_t *this_gen);
+
+/* route preprocessing functions check */
+static int            enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame);
+
+/* replaced vo_frame functions */
+static int            enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream);
+
+
+void *enigma_video_init_plugin(xine_t *xine, const void *data)
+{
+  post_class_t *class = calloc(1, sizeof (post_class_t));
+
+  (void)xine;
+  (void)data;
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_video_open_plugin;
+  class->identifier      = "enigma";
+  class->description     = N_("modifies every video frame as requested by ENIGMA");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target)
+{
+  enigma_video_post_plugin_t *this = calloc(1, sizeof (enigma_video_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_video_port_t       *port;
+
+  if (!this || !video_target || !video_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  (void)class_gen;
+  (void)inputs;
+  (void)audio_target;
+
+  _x_post_init(&this->post_plugin, 0, 1);
+  this->post_plugin.dispose = enigma_video_dispose;
+
+  port = _x_post_intercept_video_port(&this->post_plugin, video_target[ 0 ], &input, &output);
+  port->route_preprocessing_procs = enigma_video_route_preprocessing_procs;
+  port->new_frame->draw           = enigma_video_draw;
+  this->post_plugin.xine_post.video_input[ 0 ] = &port->new_port;
+
+  this->enabled          = 0;
+  this->enigma_stream    = 0;
+  this->event_queue      = 0;
+  this->old_frame_left   = 0;
+  this->old_frame_top    = 0;
+  this->old_frame_width  = 0;
+  this->old_frame_height = 0;
+  this->old_frame_ratio  = 0;
+  this->trick_speed_mode = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_video_dispose(post_plugin_t *this_gen)
+{
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = 0;
+      event_data.y = 0;
+      event_data.w = 0;
+      event_data.h = 0;
+
+      event.type        = XINE_EVENT_ENIGMA_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      xine_event_dispose_queue(this->event_queue);
+    }
+
+    free(this_gen);
+  }
+}
+
+static int enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  return !this->enabled
+    || (frame->format != XINE_IMGFMT_YUY2
+      && frame->format != XINE_IMGFMT_YV12);
+}
+
+
+static inline void enigma_video_scale(uint8_t *src, uint8_t *dst, int y_inc, int x_inc, int w_dst, int h_dst, int x, int y, int w, int h, int w_ref, int h_ref, int init)
+{
+  int x0 = x * w_dst / w_ref;
+  int y0 = y * h_dst / h_ref;
+
+  int x1 = ((x + w) * w_dst - 1 + w_ref) / w_ref;
+  int y1 = ((y + h) * h_dst - 1 + h_ref) / h_ref;
+
+  int dx = x1 - x0;
+  int dy = y1 - y0;
+
+  int yy, xx;
+
+  int dy2    = dy + dy;
+  int h_dst2 = h_dst + h_dst;
+  int y_eps  = h_dst - dy2;
+
+  int dx2    = dx + dx;
+  int w_dst2 = w_dst + w_dst;
+  int x_eps0 = w_dst - dx2;
+
+  for (yy = 0; yy < y0; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+
+  for (yy = y0; yy < y1; yy++)
+  {
+    uint8_t *dst0 = dst;
+    uint8_t *src0 = src;
+
+    int x_eps = x_eps0;
+
+    for (xx = 0; xx < x0; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    for (xx = x0; xx < x1; xx++)
+    {
+      *dst0 = *src0;
+      dst0 += x_inc;
+
+      x_eps += w_dst2;
+      while (x_eps >= 0)
+      {
+        src0  += x_inc;
+        x_eps -= dx2;
+      }
+    }
+
+    for (xx = x1; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+
+    y_eps += h_dst2;
+    while (y_eps >= 0)
+    {
+      src   += y_inc;
+      y_eps -= dy2;
+    }
+  }
+
+  for (yy = y1; yy < h_dst; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+}
+
+static void enigma_video_scale_YUY2(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] * dst->crop_top + 2 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 2,  w         , h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 1 ] + offset, &dst->base[ 0 ][ 1 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 3 ] + offset, &dst->base[ 0 ][ 3 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+static void enigma_video_scale_YV12(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] *   dst->crop_top           + 1 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 1,  w         ,  h         , this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 1 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 1 ][ 0 ] + offset, &dst->base[ 1 ][ 0 ] + offset, dst->pitches[ 1 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 2 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 2 ][ 0 ] + offset, &dst->base[ 2 ][ 0 ] + offset, dst->pitches[ 2 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+
+static int enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t       *port = (post_video_port_t *)frame->port;
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  vo_frame_t *enigma_frame;
+  xine_event_t *event;
+  int skip;
+
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->old_frame_left   = 0;
+    this->old_frame_top    = 0;
+    this->old_frame_width  = 0;
+    this->old_frame_height = 0;
+    this->old_frame_ratio  = 0;
+  }
+
+  if (!this->enigma_stream
+      && enigma_is_enigma_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_ENIGMA_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 0; /* enigma_video */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_ENIGMA_SETVIDEOWINDOW)
+      {
+        enigma_set_video_window_data_t *data = (enigma_set_video_window_data_t *)event->data;
+
+        enigma_video_set_video_window(this, data->x, data->y, data->w, data->h, data->w_ref, data->h_ref);
+      }
+      else if (event->type == XINE_EVENT_ENIGMA_TRICKSPEEDMODE)
+      {
+/*
+        fprintf(stderr, "###############################: %p, %d\n", event->data, event->data_length);
+        this->trick_speed_mode = (0 != event->data_length);
+*/
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  {
+    int32_t frame_left   = frame->crop_left;
+    int32_t frame_width  = frame->width - frame->crop_left - frame->crop_right;
+    int32_t frame_top    = frame->crop_top;
+    int32_t frame_height = frame->height - frame->crop_top - frame->crop_bottom;
+    double  frame_ratio  = frame->ratio;
+
+    if (frame_left < 0)
+      frame_left = 0;
+    if (frame_width > frame->width)
+      frame_width = frame->width;
+    if (frame_top < 0)
+      frame_top = 0;
+    if (frame_height > frame->height)
+      frame_height = frame->height;
+
+    if (this->enigma_stream
+        && frame_width != 0
+        && frame_height != 0
+        && (this->old_frame_left    != frame_left
+          || this->old_frame_top    != frame_top
+          || this->old_frame_width  != frame_width
+          || this->old_frame_height != frame_height
+          || this->old_frame_ratio  != frame_ratio))
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = frame_left;
+      event_data.y = frame_top;
+      event_data.w = frame_width;
+      event_data.h = frame_height;
+      event_data.r = frame_ratio;
+
+      xprintf(this->enigma_stream->xine, XINE_VERBOSITY_LOG,
+            _(LOG_MODULE ": osd: (%d, %d)-(%d, %d)@%lg\n"), frame_left, frame_top, frame_width, frame_height, frame_ratio);
+
+      event.type        = XINE_EVENT_ENIGMA_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      // Enigma send event
+      xine_format_change_data_t event_data_enigma;
+
+      event_data_enigma.width = frame_width;
+      event_data_enigma.height = frame_height;
+
+      int ratio = (int)(10000 * frame_ratio + 0.5);
+      int matches4_3 = abs(ratio - 13333);
+      int matches16_9 = abs(ratio - 17778);
+      if (matches4_3 < matches16_9)
+       {
+        event_data_enigma.aspect = 2;
+       }
+      else
+      {
+        event_data_enigma.aspect = 3;
+      }
+      event_data_enigma.pan_scan = 0;
+
+      event.type        = XINE_EVENT_FRAME_FORMAT_CHANGE;
+      event.data        = &event_data_enigma;
+      event.data_length = sizeof (event_data_enigma);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      this->old_frame_left   = frame_left;
+      this->old_frame_top    = frame_top;
+      this->old_frame_width  = frame_width;
+      this->old_frame_height = frame_height;
+      this->old_frame_ratio  = frame_ratio;
+    }
+  }
+/*
+  fprintf(stderr, "~~~~~~~~~~~~ trickspeedmode: %d\n", this->trick_speed_mode);
+
+  if (this->enigma_stream
+      && this->trick_speed_mode)
+  {
+    frame->pts = 0;
+    frame->next->pts = 0;
+  }
+*/
+#if defined(LOG) && defined(LOG_VERBOSE)
+  {
+    int a = 0, b = 0, c = 0, d = 0;
+    if (stream)
+      _x_query_buffer_usage(stream, &a, &b, &c, &d);
+    lprintf("buffer usage: %3d, %2d, %2d, %2d, %p\n", a, b, c, d, stream);
+  }
+#endif
+
+  if (!this->enabled
+      || frame->bad_frame
+      || (frame->format != XINE_IMGFMT_YUY2
+          && frame->format != XINE_IMGFMT_YV12)
+      || frame->proc_frame
+      || frame->proc_slice)
+  {
+    _x_post_frame_copy_down(frame, frame->next);
+    skip = frame->next->draw(frame->next, stream);
+    _x_post_frame_copy_up(frame, frame->next);
+    return skip;
+  }
+
+  enigma_frame = port->original_port->get_frame(port->original_port,
+    frame->width, frame->height, frame->ratio, frame->format, frame->flags | VO_BOTH_FIELDS);
+
+  _x_post_frame_copy_down(frame, enigma_frame);
+
+  switch (enigma_frame->format)
+  {
+  case XINE_IMGFMT_YUY2:
+    enigma_video_scale_YUY2(this, frame, enigma_frame);
+    break;
+
+  case XINE_IMGFMT_YV12:
+    enigma_video_scale_YV12(this, frame, enigma_frame);
+    break;
+  }
+
+  skip = enigma_frame->draw(enigma_frame, stream);
+  _x_post_frame_copy_up(frame, enigma_frame);
+  enigma_frame->free(enigma_frame);
+
+  return skip;
+}
diff -ruN o/src/Makefile.am pc/src/Makefile.am
--- o/src/Makefile.am	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/Makefile.am	2024-07-21 14:42:55.841005455 +0300
@@ -16,4 +16,5 @@
 	libreal \
 	post \
 	combined \
-	vdr
+	vdr \
+	e2pc
diff -ruN o/src/video_out/vaapi/vaapi_util.c pc/src/video_out/vaapi/vaapi_util.c
--- o/src/video_out/vaapi/vaapi_util.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/video_out/vaapi/vaapi_util.c	2024-07-21 14:42:55.841005455 +0300
@@ -611,9 +611,6 @@
 
 void _x_va_surface_displayed(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface)
 {
-  _x_assert(va_surface->status == SURFACE_RENDER ||
-            va_surface->status == SURFACE_RENDER_RELEASE);
-
   pthread_mutex_lock(&va_context->surfaces_lock);
 
   if (va_surface->status == SURFACE_RENDER_RELEASE) {
diff -ruN o/src/video_out/video_out_opengl.c pc/src/video_out/video_out_opengl.c
--- o/src/video_out/video_out_opengl.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/video_out/video_out_opengl.c	2024-07-21 14:42:55.842005440 +0300
@@ -134,6 +134,14 @@
 
 #define MY_2PI               (M_PI * 2)
 
+typedef struct opengl_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} opengl_argb_layer_t;
 
 typedef struct {
   vo_frame_t         vo_frame;
@@ -211,8 +219,14 @@
 
   /* Frame state */
   opengl_frame_t    *frame[NUM_FRAMES_BACKLOG];
+
+  /* Overlay */
   x11osd            *xoverlay;
+  opengl_argb_layer_t argb_layer;
   int                ovl_changed;
+  int                last_ovl_width, last_ovl_height;
+  int                tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   config_values_t   *config;
   xine_t            *xine;
@@ -242,6 +256,10 @@
     enum render_e defaction;
     /* Fallback: change to following render backend if this one doesn't work */
     int fallback;
+    /* Upload new overlay image; Returns 0 if failed */
+    int (*ovl_image)(opengl_driver_t *, opengl_frame_t *);
+    /* Display current overlay */
+    void (*ovl_display)(opengl_driver_t *, opengl_frame_t *);
 } opengl_render_t;
 
 
@@ -271,10 +289,21 @@
   float           tx, ty;
 
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
+
   tx = (float) frame->width  / this->tex_width;
   ty = (float) frame->height / this->tex_height;
   /* Draw quad */
@@ -286,6 +315,56 @@
   glEnd ();
 }
 
+/* Static Overlay display */
+static void render_overlay (opengl_driver_t *this, opengl_frame_t *frame) {
+  int             x1, x2, y1, y2;
+  float           tx, ty;
+
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  
+  if (this->tex_ovl_width == 0 && this->tex_ovl_height == 0) // Image_Pipeline renderer is active (no texture support)
+  {
+    glPixelZoom   (((float)this->gui_width)    / this->argb_layer.width,
+		((float)this->gui_height)   / this->argb_layer.height);
+    glRasterPos2i (0, 0);
+    glDrawPixels  (this->argb_layer.width, this->argb_layer.height, GL_BGRA,
+			GL_UNSIGNED_BYTE, this->argb_layer.buffer);
+  }
+  else
+  {
+    if (this->glBindTextureEXT) // bind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+
+    if (this->fprog != -1)  // 2D_Tex_Fragprog is active which uses a pixelshader to make yuv2rgb conversion
+                            // -> disable it because texture is already argb
+      glDisable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    /* Calc texture/rectangle coords */
+    x1 = 0;
+    y1 = 0;
+    x2 = this->gui_width;
+    y2 = this->gui_height;
+    tx = (float) this->argb_layer.width  / this->tex_ovl_width;
+    ty = (float) this->argb_layer.height / this->tex_ovl_height;
+
+    /* Draw quad */
+    glBegin (GL_QUADS);
+    glTexCoord2f (tx, ty);   glVertex2i (x2, y2);
+    glTexCoord2f (0,  ty);   glVertex2i (x1, y2);
+    glTexCoord2f (0,  0);    glVertex2i (x1, y1);
+    glTexCoord2f (tx, 0);    glVertex2i (x2, y1);
+    glEnd ();
+
+    if (this->fprog != -1)  // enable pixelshader for next normal video frame
+      glEnable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    if (this->glBindTextureEXT) // unbind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 0);
+  }
+  glDisable(GL_BLEND);
+}
+
 /* Static 2d texture tiled based display */
 static void render_tex2dtiled (opengl_driver_t *this, opengl_frame_t *frame) {
   int    tex_w, tex_h, frame_w, frame_h;
@@ -297,10 +376,20 @@
   frame_w = frame->width;
   frame_h = frame->height;
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
   txa = 1.0 / tex_w;
   tya = 1.0 / tex_h;
   txb = (float) frame_w / (tex_w-2);	/* temporary: total */
@@ -331,11 +420,23 @@
 
 /* Static image pipline based display */
 static void render_draw (opengl_driver_t *this, opengl_frame_t *frame) {
-  glPixelZoom   (((float)this->sc.output_width)    / frame->width,
-		 - ((float)this->sc.output_height) / frame->height);
-  glRasterPos2i (this->sc.output_xoffset, this->sc.output_yoffset);
-  glDrawPixels  (frame->width, frame->height, RGB_TEXTURE_FORMAT,
-		 GL_UNSIGNED_BYTE, frame->rgb);
+
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    glPixelZoom(((float)this->video_window_width)  / frame->width,
+                ((float)this->video_window_height) / frame->height);
+    glRasterPos2i(this->video_window_x, this->video_window_y);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
+  else
+  {
+    glPixelZoom(((float)this->sc.output_width)  / frame->width,
+                ((float)this->sc.output_height) / frame->height);
+    glRasterPos2i(this->sc.output_xoffset, this->sc.output_yoffset);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
 }
 
 /* Animated spinning cylinder */
@@ -486,6 +587,45 @@
   return 2;
 }
 
+/* holds/allocates extra texture for overlay */
+/* returns 0: allocation failure  1: texture updated  2: texture kept */
+static int render_help_overlay_image_tex(opengl_driver_t *this, int new_w, int new_h,
+				GLint glformat, GLint texformat) {
+  int tex_w, tex_h, err;
+
+  /* check necessary texture size and allocate */
+  if (new_w != this->last_ovl_width ||
+      new_h != this->last_ovl_height ||
+      ! this->tex_ovl_width || ! this->tex_ovl_height) {
+    tex_w = tex_h = 16;
+    while (tex_w < new_w)
+      tex_w <<= 1;
+    while (tex_h < new_h)
+      tex_h <<= 1;
+
+    if (tex_w != this->tex_ovl_width || tex_h != this->tex_ovl_height) {
+      char *tmp = calloc (tex_w * tex_h, 4); /* 4 enough until RGBA */
+      if (this->glBindTextureEXT)  // xine code binds without call glGenTextures -> seems to me not correct
+        this->glBindTextureEXT (GL_TEXTURE_2D, 1000);  // bind 1000 to avoid collision with tiledtex textures / don't want to rewrite everything ...
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexImage2D (GL_TEXTURE_2D, 0, glformat, tex_w, tex_h,
+			0, texformat, GL_UNSIGNED_BYTE, tmp);
+      err = glGetError ();
+      free (tmp);
+      if (err)
+		return 0;
+      this->tex_ovl_width  = tex_w;
+      this->tex_ovl_height = tex_h;
+      lprintf ("* new texsize: %dx%d\n", tex_w, tex_h);
+    }
+    this->last_ovl_width  = new_w;
+    this->last_ovl_height = new_h;
+    return 1;
+  }
+  return 2;
+}
+
 /* returns 0: allocation failure  1: textures updated  2: textures kept */
 static int render_help_image_tiledtex (opengl_driver_t *this,
 				       int new_w, int new_h,
@@ -572,6 +712,24 @@
   return 1;
 }
 
+static int render_overlay_image_tex (opengl_driver_t *this, opengl_frame_t *frame) {
+  int ret;
+
+  // use own texture
+  ret = render_help_overlay_image_tex (this, this->argb_layer.width, this->argb_layer.height,
+                                       4, GL_BGRA);
+
+  if (! ret)
+    return 0;
+
+  if (this->glBindTextureEXT)
+    this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+  glTexSubImage2D (GL_TEXTURE_2D, 0, 4, 0, this->argb_layer.width, this->argb_layer.height,
+                   GL_BGRA, GL_UNSIGNED_BYTE,
+                   this->argb_layer.buffer);
+  return 1;
+}
+
 static int render_image_tiledtex (opengl_driver_t *this, opengl_frame_t *frame) {
   int ret;
   int frame_w, frame_h, tex_w, tex_h, i, j, nx, ny;
@@ -1042,20 +1200,20 @@
 /*
  * List of render backends
  */
-/* name, display, image,  setup, needsrgb, defaction, fallback */
+/* name, display, image,  setup, needsrgb, defaction, fallback, ovl_image, ovl_display */
 static const opengl_render_t opengl_rb[] = {
     {   "2D_Tex_Fragprog",  render_tex2d, render_image_fp_yuv,
-	render_setup_fp_yuv, 0, RENDER_NONE, 1 },
+	render_setup_fp_yuv, 0, RENDER_NONE, 1, render_overlay_image_tex, render_overlay },
     {   "2D_Tex",           render_tex2d, render_image_tex,
-	render_setup_tex2d,  1, RENDER_NONE, 2 },
+	render_setup_tex2d,  1, RENDER_NONE, 2, render_overlay_image_tex, render_overlay },
     {   "2D_Tex_Tiled",     render_tex2dtiled, render_image_tiledtex,
-	render_setup_tex2d,  1, RENDER_NONE, 3 },
+	render_setup_tex2d,  1, RENDER_NONE, 3, render_overlay_image_tex, render_overlay },
     {   "Image_Pipeline",   render_draw, render_image_nop,
-	render_setup_2d,     1, RENDER_NONE, -1 },
+	render_setup_2d,     1, RENDER_NONE, -1, render_image_nop, render_overlay },
     {   "Cylinder",         render_cyl, render_image_tex,
-	render_setup_cyl,    1, RENDER_DRAW, 1 },
+	render_setup_cyl,    1, RENDER_DRAW, 1, render_image_nop, render_image_nop },
     {   "Env_Mapped_Torus", render_env_tor, render_image_envtex,
-	render_setup_torus,  1, RENDER_DRAW, 1 }
+	render_setup_torus,  1, RENDER_DRAW, 1, render_image_nop, render_image_nop }
 } ;
 
 
@@ -1147,12 +1305,27 @@
 	CHECKERR ("pre-render");
 	ret = 1;
 	if (changed)
+         if (this->argb_layer.changed) // clean window after every overlay change - do it twice because of double buffering
+         {
+      glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+      if (this->argb_layer.changed == 1)
+        this->argb_layer.changed++;
+      else this->argb_layer.changed = 0;
+    }
 	  ret = (render->image) (this, frame);
-	(render->display) (this, frame);
-	if (this->render_double_buffer)
-	  glXSwapBuffers(this->display, this->drawable);
-	else
-	  glFlush ();
+    (render->display) (this, frame);
+    // display overlay
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+    {
+      ret = (render->ovl_image) (this, frame);
+      (render->ovl_display) (this, frame);
+    }
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    if (this->render_double_buffer)
+      glXSwapBuffers(this->display, this->drawable);
+    else
+      glFlush ();
 	/* Note: no glFinish() - work concurrently to the graphics pipe */
 	CHECKERR ("post-render");
 	XUnlockDisplay (this->display);
@@ -1216,6 +1389,7 @@
 	}
 	XUnlockDisplay (this->display);
 	this->tex_width = this->tex_height = 0;
+	this->tex_ovl_width = this->tex_ovl_height = 0;
       }
       break;
 
@@ -1592,6 +1766,9 @@
   opengl_driver_t  *this  = (opengl_driver_t *) this_gen;
   opengl_frame_t   *frame = (opengl_frame_t *) frame_gen;
 
+  if (overlay->width <= 0 || overlay->height <= 0 || (!overlay->rle && (!overlay->argb_layer || !overlay->argb_layer->buffer)))
+    return;
+
   /* Alpha Blend here */
   if (overlay->rle) {
     if (overlay->unscaled) {
@@ -1633,6 +1810,28 @@
 #     endif
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  { 
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(opengl_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy(this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static int opengl_redraw_needed (vo_driver_t *this_gen) {
@@ -1946,6 +2145,11 @@
     XFree(this->vinfo);
   }
 
+  pthread_mutex_lock (&this->argb_layer.mutex);
+  if (this->argb_layer.buffer)
+       free(this->argb_layer.buffer);
+  pthread_mutex_unlock (&this->argb_layer.mutex);
+
   _x_alphablend_free(&this->alphablend_extra_data);
   _x_vo_scale_cleanup (&this->sc, this->xine->config);
 
@@ -2010,7 +2214,17 @@
   this->fprog = -1;
 
   this->xoverlay                = NULL;
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
   this->ovl_changed             = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
+  
   this->xine                    = class->xine;
   this->config                  = config;
 
diff -ruN o/src/video_out/video_out_vaapi.c pc/src/video_out/video_out_vaapi.c
--- o/src/video_out/video_out_vaapi.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/video_out/video_out_vaapi.c	2024-07-21 14:42:55.843005424 +0300
@@ -74,9 +74,9 @@
 # define ENABLE_VA_GLX
 #endif /* OPENGL */
 
+#include "accel_vaapi.h"
 #include "vaapi/vaapi_util.h"
-#include "vaapi/vaapi_frame.h"
-#include "vaapi/xine_va_display.h" /* interop flags */
+#include "mem_frame.h"
 
 #include <pthread.h>
 
@@ -144,6 +144,11 @@
 } vaapi_rect_t;
 
 typedef struct {
+  mem_frame_t       mem_frame;
+  vaapi_accel_t     vaapi_accel_data;
+} vaapi_frame_t;
+
+typedef struct {
   VADisplayAttribType type;
   int                 value;
   int                 min;
@@ -156,6 +161,15 @@
 
 } va_property_t;
 
+typedef struct vaapi_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} vaapi_argb_layer_t;
+
 struct vaapi_driver_s {
 
   vo_driver_t        vo_driver;
@@ -169,7 +183,13 @@
 
   uint32_t            capabilities;
 
+  /* Overlay */
   int ovl_changed;
+  vaapi_argb_layer_t  argb_layer;
+  int                 last_ovl_width, last_ovl_height;
+  int                 tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                 video_window_width, video_window_height, video_window_x, video_window_y;
+
   vo_overlay_t       *overlays[XINE_VORAW_MAX_OVL];
   uint32_t           *overlay_bitmap;
   uint32_t            overlay_bitmap_size;
@@ -180,6 +200,8 @@
 
   uint32_t            vdr_osd_width;
   uint32_t            vdr_osd_height;
+  uint32_t            enigma_osd_width;
+  uint32_t            enigma_osd_height;
 
   uint32_t            overlay_output_width;
   uint32_t            overlay_output_height;
@@ -214,16 +236,18 @@
   VAImage             *va_soft_images;
   unsigned int        va_soft_head;
   int                 soft_image_is_bound;
-
+  int                 is_bound;
   /* subpicture */
-  VAImageFormat       bgra_subpic_format;
-  unsigned int        bgra_subpic_flags;
+  VAImageFormat       *va_subpic_formats;
+  unsigned int        *va_subpic_flags;
+  int                 va_num_subpic_formats;
   VAImage             va_subpic_image;
   VASubpictureID      va_subpic_id;
   int                 va_subpic_width;
   int                 va_subpic_height;
   unsigned int        last_sub_image_fmt;
-  int                 overlay_mode;
+  unsigned int        num_frame_buffers;
+  vaapi_frame_t       *frames[RENDER_SURFACES];
 
   pthread_mutex_t     vaapi_lock;
 
@@ -255,16 +279,6 @@
   VASurfaceID         va_soft_surface_ids_storage[SOFT_SURFACES + 1];
   VAImage             va_soft_images_storage[SOFT_SURFACES + 1];
   vaapi_context_impl_t *va;
-
-#ifdef ENABLE_VA_GLX
-  void                (GLAPIENTRY *mpglBindTexture) (GLenum, GLuint);
-  void                (GLAPIENTRY *mpglXBindTexImage) (Display *, GLXDrawable, int, const int *);
-  void                (GLAPIENTRY *mpglXReleaseTexImage) (Display *, GLXDrawable, int);
-  GLXPixmap           (GLAPIENTRY *mpglXCreatePixmap) (Display *, GLXFBConfig, Pixmap, const int *);
-  void                (GLAPIENTRY *mpglXDestroyPixmap) (Display *, GLXPixmap);
-  const GLubyte       *(GLAPIENTRY *mpglGetString) (GLenum);
-  void                (GLAPIENTRY *mpglGenPrograms) (GLsizei, GLuint *);
-#endif
 };
 
 /* import common color matrix stuff */
@@ -279,6 +293,23 @@
 static VAStatus vaapi_destroy_soft_surfaces (vaapi_driver_t *this);
 static int vaapi_set_property (vo_driver_t *this_gen, int property, int value);
 
+static void yv12_to_nv12(const uint8_t *y_src, int y_src_pitch,
+                         const uint8_t *u_src, int u_src_pitch,
+                         const uint8_t *v_src, int v_src_pitch,
+                         uint8_t *y_dst,  int y_dst_pitch,
+                         uint8_t *uv_dst, int uv_dst_pitch,
+                         int width, int height);
+
+#ifdef ENABLE_VA_GLX
+  void                (GLAPIENTRY *mpglBindTexture) (GLenum, GLuint);
+  void                (GLAPIENTRY *mpglXBindTexImage) (Display *, GLXDrawable, int, const int *);
+  void                (GLAPIENTRY *mpglXReleaseTexImage) (Display *, GLXDrawable, int);
+  GLXPixmap           (GLAPIENTRY *mpglXCreatePixmap) (Display *, GLXFBConfig, Pixmap, const int *);
+  void                (GLAPIENTRY *mpglXDestroyPixmap) (Display *, GLXPixmap);
+  const GLubyte       *(GLAPIENTRY *mpglGetString) (GLenum);
+  void                (GLAPIENTRY *mpglGenPrograms) (GLsizei, GLuint *);
+#endif
+
 #if defined(LOG) || defined(DEBUG)
 static const char *string_of_VAImageFormat(VAImageFormat *imgfmt)
 {
@@ -301,6 +332,12 @@
   return 1;
 }
 
+static int vaapi_lock_decode_dummy(vo_frame_t *vo_frame)
+{
+  (void)vo_frame;
+  return 0;
+}
+
 static int vaapi_lock_decode_guarded(vo_frame_t *frame_gen)
 {
   vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
@@ -317,11 +354,44 @@
   pthread_mutex_unlock(&this->vaapi_lock);
 }
 
+static int guarded_render(vo_frame_t *frame_gen) {
+  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
+
+  return this->guarded_render;
+}
+
+static ff_vaapi_surface_t *get_vaapi_surface(vo_frame_t *frame_gen) {
+  vaapi_driver_t      *this       = (vaapi_driver_t *) frame_gen->driver;
+  vaapi_frame_t       *frame      = (vaapi_frame_t *) frame_gen;
+  ff_vaapi_context_t  *va_context = this->va_context;
+  return &va_context->va_render_surfaces[frame->vaapi_accel_data.index];
+}
+
+static ff_vaapi_surface_t *alloc_vaapi_surface(vo_frame_t *frame_gen) {
+
+  vaapi_driver_t      *this       = (vaapi_driver_t *) frame_gen->driver;
+
+  return _x_va_alloc_surface(this->va);
+}
+
+static void render_vaapi_surface(vo_frame_t *frame_gen, ff_vaapi_surface_t *va_surface) {
+  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
+  vaapi_accel_t *accel = (vaapi_accel_t*)frame_gen->accel_data;
+
+  accel->index = va_surface->index;
+  _x_va_render_surface(this->va, va_surface);
+}
+
+static void release_vaapi_surface(vo_frame_t *frame_gen, ff_vaapi_surface_t *va_surface) {
+  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
+
+  _x_va_release_surface(this->va, va_surface);
+}
+
 typedef struct {
   video_driver_class_t driver_class;
 
   xine_t              *xine;
-  unsigned             visual_type;
 } vaapi_class_t;
 
 static void vaapi_x11_wait_event(Display *dpy, Window w, int type)
@@ -356,21 +426,19 @@
 
 #ifdef ENABLE_VA_GLX
 
-static void vaapi_appendstr (char **dst, size_t *len, const char *str) {
-  size_t newsize, slen;
-  char *newstr;
-
-  if (!str)
-    return;
-  slen = strlen (str);
-  newsize = *len + 1 + slen;
-  newstr = realloc (*dst, newsize + 1);
-  if (!newstr)
-    return;
-  *dst = newstr;
-  newstr[*len] = ' ';
-  memcpy (newstr + *len + 1, str, slen + 1);
-  *len = newsize;
+static void vaapi_appendstr(char **dst, const char *str)
+{
+    int newsize;
+    char *newstr;
+    if (!str)
+        return;
+    newsize = strlen(*dst) + 1 + strlen(str) + 1;
+    newstr = realloc(*dst, newsize);
+    if (!newstr)
+        return;
+    *dst = newstr;
+    strcat(*dst, " ");
+    strcat(*dst, str);
 }
 
 /* Return the address of a linked function */
@@ -386,54 +454,60 @@
 }
 
 /* Resolve opengl functions. */
-static void vaapi_get_functions (vaapi_driver_t *this, void *(*getProcAddress)(const GLubyte *), const char *ext2) {
+static void vaapi_get_functions (void *(*getProcAddress)(const GLubyte *), const char *ext2) {
+  static const struct {
+    void       *funcptr;
+    const char *extstr;
+    const char *funcnames[4];
+  } extfuncs[] = {
+    { &mpglBindTexture,
+      NULL,
+      { "glBindTexture", "glBindTextureARB", "glBindTextureEXT", NULL } },
+    { &mpglXBindTexImage,
+      "GLX_EXT_texture_from_pixmap",
+      {" glXBindTexImageEXT", NULL }, },
+    { &mpglXReleaseTexImage,
+      "GLX_EXT_texture_from_pixmap",
+      { "glXReleaseTexImageEXT", NULL} },
+    { &mpglXCreatePixmap,
+      "GLX_EXT_texture_from_pixmap",
+      { "glXCreatePixmap", NULL } },
+    { &mpglXDestroyPixmap,
+      "GLX_EXT_texture_from_pixmap",
+      { "glXDestroyPixmap", NULL } },
+    { &mpglGenPrograms, "_program",
+      { "glGenProgramsARB", NULL } },
+};
+
   const char *extensions;
   char *allexts;
-  size_t l1, l2;
+  size_t ext;
 
   if (!getProcAddress)
     getProcAddress = (void *)vaapi_getdladdr;
 
   /* special case, we need glGetString before starting to find the other functions */
-  this->mpglGetString = getProcAddress ("glGetString");
-  if (!this->mpglGetString)
-    this->mpglGetString = glGetString;
-
-  extensions = (const char *)this->mpglGetString (GL_EXTENSIONS);
-  if (!extensions)
-    extensions = "";
-  if (!ext2)
-    ext2 = "";
-  l1 = strlen (extensions);
-  l2 = strlen (ext2);
-  allexts = malloc (l1 + 1 + l2 + 1);
-  memcpy (allexts, extensions, l1);
-  allexts[l1] = ' ';
-  memcpy (allexts + l1 + 1, ext2, l2);
-  allexts[l1 + 1 + l2] = 0;
+  mpglGetString = getProcAddress ("glGetString");
+  if (!mpglGetString)
+      mpglGetString = glGetString;
+
+  extensions = (const char *)mpglGetString (GL_EXTENSIONS);
+  if (!extensions) extensions = "";
+  if (!ext2) ext2 = "";
+  allexts = malloc(strlen(extensions) + strlen(ext2) + 2);
+  strcpy(allexts, extensions);
+  strcat(allexts, " ");
+  strcat(allexts, ext2);
   lprintf("vaapi_get_functions: OpenGL extensions string:\n%s\n", allexts);
-
-  this->mpglBindTexture = getProcAddress ((const GLubyte *)"glBindTexture");
-  if (!this->mpglBindTexture)
-    this->mpglBindTexture = getProcAddress ((const GLubyte *)"glBindTextureARB");
-  if (!this->mpglBindTexture)
-    this->mpglBindTexture = getProcAddress ((const GLubyte *)"glBindTextureEXT");
-  
-  this->mpglXBindTexImage = NULL;
-  this->mpglXReleaseTexImage = NULL;
-  this->mpglXCreatePixmap = NULL;
-  this->mpglXDestroyPixmap = NULL;
-  if (strstr (allexts, "GLX_EXT_texture_from_pixmap")) {
-    this->mpglXBindTexImage = getProcAddress ((const GLubyte *)"glXBindTexImageEXT");
-    this->mpglXReleaseTexImage = getProcAddress ((const GLubyte *)"glXReleaseTexImageEXT");
-    this->mpglXCreatePixmap = getProcAddress ((const GLubyte *)"glXCreatePixmap");
-    this->mpglXDestroyPixmap = getProcAddress ((const GLubyte *)"glXDestroyPixmap");
+  for (ext = 0; ext < sizeof(extfuncs) / sizeof(extfuncs[0]); ext++) {
+    void *ptr = NULL;
+    int i;
+    if (!extfuncs[ext].extstr || strstr(allexts, extfuncs[ext].extstr)) {
+      for (i = 0; !ptr && extfuncs[ext].funcnames[i]; i++)
+        ptr = getProcAddress((const GLubyte *)extfuncs[ext].funcnames[i]);
+    }
+    *(void **)extfuncs[ext].funcptr = ptr;
   }
-
-  this->mpglGenPrograms = NULL;
-  if (strstr (allexts, "_program"))
-    this->mpglGenPrograms = getProcAddress ((const GLubyte *)"glGenProgramsARB");
-
   lprintf("\n");
   free(allexts);
 }
@@ -498,11 +572,11 @@
 static int vaapi_glx_bind_texture(vaapi_driver_t *this)
 {
   glEnable(GL_TEXTURE_2D);
-  this->mpglBindTexture (GL_TEXTURE_2D, this->gl_texture);
+  mpglBindTexture (GL_TEXTURE_2D, this->gl_texture);
 
   if (this->opengl_use_tfp) {
     vaapi_x11_trap_errors();
-    this->mpglXBindTexImage (this->display, this->gl_pixmap, GLX_FRONT_LEFT_EXT, NULL);
+    mpglXBindTexImage (this->display, this->gl_pixmap, GLX_FRONT_LEFT_EXT, NULL);
     XSync(this->display, False);
     if (vaapi_x11_untrap_errors())
       xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_bind_texture : Update bind_tex_image failed\n");
@@ -515,12 +589,12 @@
 {
   if (this->opengl_use_tfp) {
     vaapi_x11_trap_errors();
-    this->mpglXReleaseTexImage (this->display, this->gl_pixmap, GLX_FRONT_LEFT_EXT);
+    mpglXReleaseTexImage (this->display, this->gl_pixmap, GLX_FRONT_LEFT_EXT);
     if (vaapi_x11_untrap_errors())
       xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_unbind_texture : Failed to release?\n");
   }
 
-  this->mpglBindTexture (GL_TEXTURE_2D, 0);
+  mpglBindTexture (GL_TEXTURE_2D, 0);
   glDisable(GL_TEXTURE_2D);
   return 0;
 }
@@ -596,7 +670,7 @@
 
   if(this->gl_pixmap) {
     vaapi_x11_trap_errors();
-    this->mpglXDestroyPixmap (this->display, this->gl_pixmap);
+    mpglXDestroyPixmap (this->display, this->gl_pixmap);
     XSync(this->display, False);
     if (vaapi_x11_untrap_errors())
       xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_destroy_glx : mpglXDestroyPixmap failed\n");
@@ -649,7 +723,6 @@
 
         visual_depth = vi->depth;
         XFree(vi);
-        vi = NULL;
 
         if (visual_depth != depth)
             continue;
@@ -709,7 +782,7 @@
   int attribs[7], i = 0;
   const int depth = 24;
 
-  if (!this->mpglXBindTexImage || !this->mpglXReleaseTexImage) {
+  if (!mpglXBindTexImage || !mpglXReleaseTexImage) {
     xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_tfp : No GLX texture-from-pixmap extension available\n");
     return 0;
   }
@@ -743,7 +816,7 @@
   attribs[i++] = None;
 
   vaapi_x11_trap_errors();
-  this->gl_pixmap = this->mpglXCreatePixmap(this->display, *fbconfig, this->gl_image_pixmap, attribs);
+  this->gl_pixmap = mpglXCreatePixmap(this->display, *fbconfig, this->gl_image_pixmap, attribs);
   XSync(this->display, False);
   if (vaapi_x11_untrap_errors()) {
     xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_tfp : Could not create GLX pixmap\n");
@@ -764,105 +837,101 @@
     this->opengl_render = 0;
   }
 
-  do {
-    void *(*getProcAddress) (const GLubyte *);
-    const char *(*glXExtStr) (Display *, int);
-    char *glxstr;
-    size_t slen;
-
-    glXMakeCurrent (this->display, None, NULL);
-    this->gl_context = glXCreateContext (this->display, gl_vinfo, NULL, True);
-    XFree (gl_vinfo);
-    gl_vinfo = NULL;
-    if (this->gl_context) {
-      if (!glXMakeCurrent (this->display, this->window, this->gl_context)) {
-        xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : error glXMakeCurrent\n");
-        break;
-      }
-    } else {
-      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : error glXCreateContext\n");
-      break;
+  glXMakeCurrent(this->display, None, NULL);
+  this->gl_context = glXCreateContext (this->display, gl_vinfo, NULL, True);
+  XFree(gl_vinfo);
+  if (this->gl_context) {
+    if(!glXMakeCurrent (this->display, this->window, this->gl_context)) {
+      xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : error glXMakeCurrent\n");
+      goto error;
     }
+  } else {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : error glXCreateContext\n");
+    goto error;
+  }
 
-    glxstr = strdup (" ");
-    slen = 0;
-    getProcAddress = vaapi_getdladdr ("glXGetProcAddress");
-    if (!getProcAddress)
-      getProcAddress = vaapi_getdladdr ("glXGetProcAddressARB");
-    glXExtStr = vaapi_getdladdr ("glXQueryExtensionsString");
-    if (glXExtStr)
-      vaapi_appendstr (&glxstr, &slen, glXExtStr (this->display, this->screen));
-    glXExtStr = vaapi_getdladdr ("glXGetClientString");
-    if (glXExtStr)
-      vaapi_appendstr (&glxstr, &slen, glXExtStr (this->display, GLX_EXTENSIONS));
-    glXExtStr = vaapi_getdladdr ("glXGetServerString");
-    if (glXExtStr)
-      vaapi_appendstr (&glxstr, &slen, glXExtStr(this->display, GLX_EXTENSIONS));
-
-    vaapi_get_functions (this, getProcAddress, glxstr);
-    if (!this->mpglGenPrograms && this->mpglGetString && getProcAddress &&
-      strstr (this->mpglGetString (GL_EXTENSIONS), "GL_ARB_vertex_program")) {
-      xprintf (this->xine, XINE_VERBOSITY_LOG,
-        LOG_MODULE " vaapi_glx_config_glx : Broken glXGetProcAddress detected, trying workaround\n");
-      vaapi_get_functions (this, NULL, glxstr);
-    }
-    free (glxstr);
-    glxstr = NULL;
-
-    glDisable (GL_DEPTH_TEST);
-    glDepthMask (GL_FALSE);
-    glDisable (GL_CULL_FACE);
-    glEnable (GL_TEXTURE_2D);
-    glDrawBuffer (GL_BACK);
-    glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-    glEnable (GL_BLEND);
-    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-
-    /* Create TFP resources */
-    if (this->opengl_use_tfp && vaapi_glx_config_tfp (this, width, height)) {
-      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : Using GLX texture-from-pixmap extension\n");
-    } else {
-      this->opengl_use_tfp = 0;
-    }
+  void *(*getProcAddress)(const GLubyte *);
+  const char *(*glXExtStr)(Display *, int);
+  char *glxstr = strdup(" ");
 
-    /* Create OpenGL texture */
-    /* XXX: assume GL_ARB_texture_non_power_of_two is available */
-    glEnable (GL_TEXTURE_2D);
-    glGenTextures (1, &this->gl_texture);
-    this->mpglBindTexture (GL_TEXTURE_2D, this->gl_texture);
-    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    if (!this->opengl_use_tfp) {
-      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-      glPixelStorei (GL_UNPACK_ALIGNMENT, 4);
-      glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
-    }
-    this->mpglBindTexture (GL_TEXTURE_2D, 0);
-    glDisable (GL_TEXTURE_2D);
+  getProcAddress = vaapi_getdladdr("glXGetProcAddress");
+  if (!getProcAddress)
+    getProcAddress = vaapi_getdladdr("glXGetProcAddressARB");
+  glXExtStr = vaapi_getdladdr("glXQueryExtensionsString");
+  if (glXExtStr)
+      vaapi_appendstr(&glxstr, glXExtStr(this->display, this->screen));
+  glXExtStr = vaapi_getdladdr("glXGetClientString");
+  if (glXExtStr)
+      vaapi_appendstr(&glxstr, glXExtStr(this->display, GLX_EXTENSIONS));
+  glXExtStr = vaapi_getdladdr("glXGetServerString");
+  if (glXExtStr)
+      vaapi_appendstr(&glxstr, glXExtStr(this->display, GLX_EXTENSIONS));
+
+  vaapi_get_functions(getProcAddress, glxstr);
+  if (!mpglGenPrograms && mpglGetString &&
+      getProcAddress &&
+      strstr(mpglGetString(GL_EXTENSIONS), "GL_ARB_vertex_program")) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : Broken glXGetProcAddress detected, trying workaround\n");
+    vaapi_get_functions(NULL, glxstr);
+  }
+  free(glxstr);
+
+  glDisable(GL_DEPTH_TEST);
+  glDepthMask(GL_FALSE);
+  glDisable(GL_CULL_FACE);
+  glEnable(GL_TEXTURE_2D);
+  glDrawBuffer(GL_BACK);
+  glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  /* Create TFP resources */
+  if(this->opengl_use_tfp && vaapi_glx_config_tfp(this, width, height)) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : Using GLX texture-from-pixmap extension\n");
+  } else {
+    this->opengl_use_tfp = 0;
+  }
 
-    glClearColor (0.0, 0.0, 0.0, 1.0);
-    glClear (GL_COLOR_BUFFER_BIT);
+  /* Create OpenGL texture */
+  /* XXX: assume GL_ARB_texture_non_power_of_two is available */
+  glEnable(GL_TEXTURE_2D);
+  glGenTextures(1, &this->gl_texture);
+  mpglBindTexture(GL_TEXTURE_2D, this->gl_texture);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  if (!this->opengl_use_tfp) {
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,
+                 GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+  }
+  mpglBindTexture(GL_TEXTURE_2D, 0);
+  glDisable(GL_TEXTURE_2D);
 
-    if (!this->gl_texture) {
-      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : gl_texture NULL\n");
-      break;
-    }
+  glClearColor(0.0, 0.0, 0.0, 1.0);
+  glClear(GL_COLOR_BUFFER_BIT);
 
-    if (!this->opengl_use_tfp) {
-      VAStatus vaStatus = vaCreateSurfaceGLX (va_context->va_display, GL_TEXTURE_2D, this->gl_texture, &this->gl_surface);
-      if (!vaapi_check_status (this, vaStatus, "vaCreateSurfaceGLX()")) {
-        this->gl_surface = NULL;
-        break;
-      }
-    } else {
+  if(!this->gl_texture) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_glx_config_glx : gl_texture NULL\n");
+    goto error;
+  }
+
+  if(!this->opengl_use_tfp) {
+    VAStatus vaStatus = vaCreateSurfaceGLX(va_context->va_display, GL_TEXTURE_2D, this->gl_texture, &this->gl_surface);
+    if(!vaapi_check_status(this, vaStatus, "vaCreateSurfaceGLX()")) {
       this->gl_surface = NULL;
+      goto error;
     }
+  } else {
+    this->gl_surface = NULL;
+  }
 
-    lprintf ("vaapi_glx_config_glx : GL setup done\n");
-    return 1;
-  } while (0);
+  lprintf ("vaapi_glx_config_glx : GL setup done\n");
 
+  return 1;
+
+error:
   destroy_glx (this);
   return 0;
 }
@@ -875,6 +944,16 @@
   return this->capabilities;
 }
 
+static int profile_from_imgfmt(vo_frame_t *frame_gen, unsigned format)
+{
+  vo_driver_t         *this_gen   = (vo_driver_t *) frame_gen->driver;
+  vaapi_driver_t      *this       = (vaapi_driver_t *) this_gen;
+
+  _x_assert(this->va->c.va_display);
+
+  return _x_va_profile_from_imgfmt(this->va, format);
+}
+
 /* Init subpicture */
 static void vaapi_init_subpicture(vaapi_driver_t *this) {
   this->va_subpic_width               = 0;
@@ -888,8 +967,9 @@
   this->overlay_bitmap = NULL;
   this->overlay_bitmap_size = 0;
 
-  this->bgra_subpic_format.fourcc = 0;
-  this->bgra_subpic_flags = 0;
+  this->va_subpic_formats     = NULL;
+  this->va_subpic_flags       = NULL;
+  this->va_num_subpic_formats = 0;
 }
 
 /* Close vaapi  */
@@ -911,6 +991,12 @@
   _x_va_close(this->va);
 }
 
+static ff_vaapi_context_t *get_context(vo_frame_t *frame_gen) {
+  vaapi_driver_t        *this = (vaapi_driver_t *) frame_gen->driver;
+
+  return this->va_context;
+}
+
 /* Deassociate and free subpicture */
 static void vaapi_destroy_subpicture(vaapi_driver_t *this) {
   ff_vaapi_context_t    *va_context = this->va_context;
@@ -931,31 +1017,38 @@
 
 /* Create VAAPI subpicture */
 static VAStatus vaapi_create_subpicture(vaapi_driver_t *this, int width, int height) {
-  do {
-    ff_vaapi_context_t *va_context = this->va_context;
-    void *p_base = NULL;
-    VAStatus vaStatus;
+  ff_vaapi_context_t  *va_context = this->va_context;
+  VAStatus            vaStatus;
 
-    if (!va_context->valid_context || !this->bgra_subpic_format.fourcc)
-      return VA_STATUS_ERROR_UNKNOWN;
+  int i = 0;
 
-    vaStatus = vaCreateImage (va_context->va_display, &this->bgra_subpic_format, width, height, &this->va_subpic_image);
-    if (!vaapi_check_status (this, vaStatus, "vaCreateImage()"))
-      break;
+  if(!va_context->valid_context || !this->va_subpic_formats || this->va_num_subpic_formats == 0)
+    return VA_STATUS_ERROR_UNKNOWN;
 
-    vaStatus = vaCreateSubpicture (va_context->va_display, this->va_subpic_image.image_id, &this->va_subpic_id);
-    if (!vaapi_check_status (this, vaStatus, "vaCreateSubpicture()"))
-      break;
+  for (i = 0; i < this->va_num_subpic_formats; i++) {
+    if ( this->va_subpic_formats[i].fourcc == VA_FOURCC('B','G','R','A')) {
 
-    if ((this->va_subpic_image.image_id == VA_INVALID_ID) || (this->va_subpic_id == VA_INVALID_ID))
-      break;
+      vaStatus = vaCreateImage( va_context->va_display, &this->va_subpic_formats[i], width, height, &this->va_subpic_image );
+      if(!vaapi_check_status(this, vaStatus, "vaCreateImage()"))
+        goto error;
+
+      vaStatus = vaCreateSubpicture(va_context->va_display, this->va_subpic_image.image_id, &this->va_subpic_id );
+      if(!vaapi_check_status(this, vaStatus, "vaCreateSubpicture()"))
+        goto error;
+    }
+  }
+
+  if (this->va_subpic_image.image_id == VA_INVALID_ID || this->va_subpic_id == VA_INVALID_ID)
+    goto error;
+
+  void *p_base = NULL;
 
     lprintf ("create sub 0x%08x 0x%08x 0x%08x\n", this->va_subpic_id,
       this->va_subpic_image.image_id, this->va_subpic_image.buf);
 
     vaStatus = vaMapBuffer(va_context->va_display, this->va_subpic_image.buf, &p_base);
     if (!vaapi_check_status(this, vaStatus, "vaMapBuffer()"))
-      break;
+    goto error;
 
     memset ((uint32_t *)p_base, 0x0, this->va_subpic_image.data_size);
     vaStatus = vaUnmapBuffer(va_context->va_display, this->va_subpic_image.buf);
@@ -967,9 +1060,9 @@
     lprintf ("vaapi_create_subpicture 0x%08x format %s\n", this->va_subpic_image.image_id,
       string_of_VAImageFormat(&this->va_subpic_image.format));
 
-    return VA_STATUS_SUCCESS;
-  } while (0);
+  return VA_STATUS_SUCCESS;
 
+error:
   /* house keeping */
   if (this->va_subpic_id != VA_INVALID_ID)
     vaapi_destroy_subpicture(this);
@@ -1057,9 +1150,69 @@
       float contrast = vaapi_normalized_prop (that, VO_PROP_CONTRAST);
       float brightness = (vaapi_normalized_prop (that, VO_PROP_BRIGHTNESS) - 1.0) * 128.0;
       float *matrix = that->user_csc_matrix;
+      float uvcos = saturation * cos( hue );
+      float uvsin = saturation * sin( hue );
+      int i;
       VADisplayAttribute attr;
 
-      cm_fill_matrix(matrix, color_matrix, hue, saturation, contrast, brightness);
+      if ((color_matrix >> 1) == 8) {
+        /* YCgCo. This is really quite simple. */
+        uvsin *= contrast;
+        uvcos *= contrast;
+        /* matrix[rgb][yuv1] */
+        matrix[1] = -1.0 * uvcos - 1.0 * uvsin;
+        matrix[2] =  1.0 * uvcos - 1.0 * uvsin;
+        matrix[5] =  1.0 * uvcos;
+        matrix[6] =                1.0 * uvsin;
+        matrix[9] = -1.0 * uvcos + 1.0 * uvsin;
+        matrix[10] = -1.0 * uvcos - 1.0 * uvsin;
+        for (i = 0; i < 12; i += 4) {
+          matrix[i] = contrast;
+          matrix[i + 3] = (brightness * contrast - 128.0 * (matrix[i + 1] + matrix[i + 2])) / 255.0;
+        }
+      } else {
+        /* YCbCr */
+        float kb, kr;
+        float vr, vg, ug, ub;
+        float ygain, yoffset;
+
+        switch (color_matrix >> 1) {
+          case 1:  kb = 0.0722; kr = 0.2126; break; /* ITU-R 709 */
+          case 4:  kb = 0.1100; kr = 0.3000; break; /* FCC */
+          case 7:  kb = 0.0870; kr = 0.2120; break; /* SMPTE 240 */
+          default: kb = 0.1140; kr = 0.2990;        /* ITU-R 601 */
+        }
+        vr = 2.0 * (1.0 - kr);
+        vg = -2.0 * kr * (1.0 - kr) / (1.0 - kb - kr);
+        ug = -2.0 * kb * (1.0 - kb) / (1.0 - kb - kr);
+        ub = 2.0 * (1.0 - kb);
+
+        if (color_matrix & 1) {
+          /* fullrange mode */
+          yoffset = brightness;
+          ygain = contrast;
+          uvcos *= contrast * 255.0 / 254.0;
+          uvsin *= contrast * 255.0 / 254.0;
+        } else {
+          /* mpeg range */
+          yoffset = brightness - 16.0;
+          ygain = contrast * 255.0 / 219.0;
+          uvcos *= contrast * 255.0 / 224.0;
+          uvsin *= contrast * 255.0 / 224.0;
+        }
+
+        /* matrix[rgb][yuv1] */
+        matrix[1] = -uvsin * vr;
+        matrix[2] = uvcos * vr;
+        matrix[5] = uvcos * ug - uvsin * vg;
+        matrix[6] = uvcos * vg + uvsin * ug;
+        matrix[9] = uvcos * ub;
+        matrix[10] = uvsin * ub;
+        for (i = 0; i < 12; i += 4) {
+          matrix[i] = ygain;
+          matrix[i + 3] = (yoffset * ygain - 128.0 * (matrix[i + 1] + matrix[i + 2])) / 255.0;
+        }
+      }
 
       attr.type   = VADisplayAttribCSCMatrix;
       /* libva design bug: VADisplayAttribute.value is plain int.
@@ -1300,7 +1453,6 @@
       }
     }
     free(display_attrs);
-    display_attrs = NULL;
   }
 
   if (this->have_user_csc_matrix) {
@@ -1378,46 +1530,42 @@
 }
 
 static VAStatus vaapi_init_soft_surfaces(vaapi_driver_t *this, int width, int height) {
+  ff_vaapi_context_t  *va_context = this->va_context;
+  VAStatus            vaStatus;
+  int                 i;
+
   vaapi_destroy_soft_surfaces(this);
 
-  do {
-    ff_vaapi_context_t *va_context = this->va_context;
-    VAStatus vaStatus;
-    int i;
+  vaStatus = vaCreateSurfaces(va_context->va_display, VA_RT_FORMAT_YUV420, width, height, this->va_soft_surface_ids, SOFT_SURFACES, NULL, 0);
+  if(!vaapi_check_status(this, vaStatus, "vaCreateSurfaces()"))
+    goto error;
 
-    vaStatus = vaCreateSurfaces (va_context->va_display,
-      VA_RT_FORMAT_YUV420, width, height, this->va_soft_surface_ids, SOFT_SURFACES, NULL, 0);
-    if (!vaapi_check_status (this, vaStatus, "vaCreateSurfaces()"))
-      break;
+  /* allocate software surfaces */
+  for(i = 0; i < SOFT_SURFACES; i++) {
 
-    /* allocate software surfaces */
-    for (i = 0; i < SOFT_SURFACES; i++) {
-      vaStatus = _x_va_create_image (this->va,
-        this->va_soft_surface_ids[i], &this->va_soft_images[i], width, height, 1, &this->soft_image_is_bound);
-      if (!vaapi_check_status(this, vaStatus, "_x_va_create_image()")) {
-        this->va_soft_images[i].image_id = VA_INVALID_ID;
-        break;
-      }
-      if (!this->soft_image_is_bound) {
-        vaStatus = vaPutImage (va_context->va_display,
-          this->va_soft_surface_ids[i], this->va_soft_images[i].image_id,
-          0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height,
-          0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height);
-        vaapi_check_status (this, vaStatus, "vaPutImage()");
-      }
+    vaStatus = _x_va_create_image(this->va, this->va_soft_surface_ids[i], &this->va_soft_images[i], width, height, 1, &this->soft_image_is_bound);
+    if (!vaapi_check_status(this, vaStatus, "_x_va_create_image()")) {
+      this->va_soft_images[i].image_id = VA_INVALID_ID;
+      goto error;
+    }
+
+    if (!this->soft_image_is_bound) {
+      vaStatus = vaPutImage(va_context->va_display, this->va_soft_surface_ids[i], this->va_soft_images[i].image_id,
+               0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height,
+               0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height);
+      vaapi_check_status(this, vaStatus, "vaPutImage()");
+    }
 #ifdef DEBUG_SURFACE
-      printf("vaapi_init_soft_surfaces 0x%08x\n", this->va_soft_surface_ids[i]);
+    printf("vaapi_init_soft_surfaces 0x%08x\n", this->va_soft_surface_ids[i]);
 #endif
-    }
-    if (i < SOFT_SURFACES)
-      break;
+  }
 
-    this->sw_width  = width;
-    this->sw_height = height;
-    this->va_soft_head = 0;
-    return VA_STATUS_SUCCESS;
-  } while (0);
+  this->sw_width  = width;
+  this->sw_height = height;
+  this->va_soft_head = 0;
+  return VA_STATUS_SUCCESS;
 
+error:
   this->sw_width  = 0;
   this->sw_height = 0;
   vaapi_destroy_soft_surfaces (this);
@@ -1428,8 +1576,6 @@
   int i, n = 0;
   for (i = 0; i < VO_NUM_RECENT_FRAMES; i++) {
     if (this->recent_frames[i]) {
-      if (this->guarded_render && this->recent_frames[i]->format == XINE_IMGFMT_VAAPI)
-        _x_va_frame_displayed(this->recent_frames[i]);
       this->recent_frames[i]->free (this->recent_frames[i]);
       this->recent_frames[i] = NULL;
       n++;
@@ -1439,6 +1585,7 @@
 }
 
 static VAStatus vaapi_init_internal(vaapi_driver_t *this, int va_profile, int width, int height) {
+  int                 i;
   VAStatus            vaStatus;
 
   vaapi_close(this);
@@ -1449,10 +1596,16 @@
   if (vaStatus != VA_STATUS_SUCCESS)
     goto error;
 
-#if 0
-  int i;
+  /* xine was told to allocate RENDER_SURFACES frames. assign the frames the rendering surfaces. */
   for(i = 0; i < RENDER_SURFACES; i++) {
-    if(this->va->frames[i]) {
+    if(this->frames[i]) {
+      vaapi_frame_t *frame                  = this->frames[i];
+      if (!this->guarded_render) {
+        frame->vaapi_accel_data.index = i;
+      } else {
+        frame->vaapi_accel_data.index = RENDER_SURFACES; /* invalid */
+      }
+#if 0
       /* this seems to break decoding to the surface ? */
       VAImage va_image;
       int is_bound;
@@ -1463,12 +1616,12 @@
                               0, 0, va_image.width, va_image.height);
         _x_va_destroy_image(this->va, &va_image);
       }
+#endif
     }
 #ifdef DEBUG_SURFACE
     printf("vaapi_init_internal 0x%08x\n", va_context->va_surface_ids[i]);
 #endif
   }
-#endif
 
   vaStatus = vaapi_init_soft_surfaces(this, width, height);
   if(!vaapi_check_status(this, vaStatus, "vaapi_init_soft_surfaces()")) {
@@ -1532,38 +1685,66 @@
   return vaStatus;
 }
 
+static void vaapi_frame_dispose (vo_frame_t *vo_img) {
+  vaapi_driver_t *this  = (vaapi_driver_t *) vo_img->driver;
+  vaapi_frame_t  *frame = xine_container_of(vo_img, vaapi_frame_t, mem_frame.vo_frame);
+  vaapi_accel_t  *accel = &frame->vaapi_accel_data;
+
+  lprintf("vaapi_frame_dispose\n");
+
+  if (this->guarded_render && accel->index < RENDER_SURFACES) {
+    ff_vaapi_surface_t *va_surface = &this->va_context->va_render_surfaces[accel->index];
+    va_surface->status = SURFACE_FREE;
+  }
+
+  _mem_frame_dispose(vo_img);
+}
+
 static vo_frame_t *vaapi_alloc_frame (vo_driver_t *this_gen) {
-  vaapi_driver_t  *this = xine_container_of(this_gen, vaapi_driver_t, vo_driver);
+  vaapi_driver_t  *this = (vaapi_driver_t *) this_gen;
   vaapi_frame_t   *frame;
   static const struct vaapi_accel_funcs_s accel_funcs = {
     .vaapi_init                = vaapi_init,
-    .profile_from_imgfmt       = _x_va_accel_profile_from_imgfmt,
-    .get_context               = _x_va_accel_get_context,
-    .lock_vaapi                = _x_va_accel_lock_decode_dummy,
+    .profile_from_imgfmt       = profile_from_imgfmt,
+    .get_context               = get_context,
+    .lock_vaapi                = vaapi_lock_decode_dummy,
     .unlock_vaapi              = NULL,
 
-    .get_vaapi_surface         = _x_va_accel_get_vaapi_surface,
+    .get_vaapi_surface         = get_vaapi_surface,
     .render_vaapi_surface      = NULL,
     .release_vaapi_surface     = NULL,
-    .guarded_render            = _x_va_accel_guarded_render,
+    .guarded_render            = guarded_render,
   };
   static const struct vaapi_accel_funcs_s accel_funcs_guarded = {
     .vaapi_init                = vaapi_init,
-    .profile_from_imgfmt       = _x_va_accel_profile_from_imgfmt,
-    .get_context               = _x_va_accel_get_context,
+    .profile_from_imgfmt       = profile_from_imgfmt,
+    .get_context               = get_context,
     .lock_vaapi                = vaapi_lock_decode_guarded,
     .unlock_vaapi              = vaapi_unlock_decode_guarded,
 
-    .get_vaapi_surface         = _x_va_accel_alloc_vaapi_surface,
-    .render_vaapi_surface      = _x_va_accel_render_vaapi_surface,
-    .release_vaapi_surface     = _x_va_accel_release_vaapi_surface,
-    .guarded_render            = _x_va_accel_guarded_render,
+    .get_vaapi_surface         = alloc_vaapi_surface,
+    .render_vaapi_surface      = render_vaapi_surface,
+    .release_vaapi_surface     = release_vaapi_surface,
+    .guarded_render            = guarded_render,
   };
 
-  frame = _x_va_frame_alloc_frame(this->va, this_gen, this->guarded_render);
+  if (this->num_frame_buffers >= sizeof(this->frames) / sizeof(this->frames[0])) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " alloc_frame: "
+            "frame limit (%u) exceeded\n", this->num_frame_buffers);
+    return NULL;
+  }
+
+  frame = (vaapi_frame_t *)_mem_frame_alloc_frame(this_gen, sizeof(vaapi_frame_t));
+
   if (!frame)
     return NULL;
 
+  frame->mem_frame.vo_frame.dispose = vaapi_frame_dispose;
+
+  this->frames[this->num_frame_buffers++] = frame;
+
+  frame->mem_frame.vo_frame.accel_data = &frame->vaapi_accel_data;
+
   /* override accel functions */
   frame->vaapi_accel_data.f = this->guarded_render ? &accel_funcs_guarded : &accel_funcs;
 
@@ -1637,16 +1818,32 @@
 
     if(format == XINE_IMGFMT_VAAPI) {
       lprintf("vaapi_ovl_associate hw\n");
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
+      vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
+                              va_context->va_surface_ids, RENDER_SURFACES,
+                              0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
+                              0, 0, this->overlay_bitmap_width, this->overlay_bitmap_height, VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD);
+      } else {
       vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
                               va_context->va_surface_ids, RENDER_SURFACES,
                               0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
                               0, 0, output_width, output_height, flags);
+             }
     } else {
       lprintf("vaapi_ovl_associate sw\n");
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
+      vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
+                              this->va_soft_surface_ids, SOFT_SURFACES,
+                              0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
+                              0, 0, this->overlay_bitmap_width, this->overlay_bitmap_height, VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD);
+      } else {
       vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
                               this->va_soft_surface_ids, SOFT_SURFACES,
                               0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
                               0, 0, this->va_soft_images[0].width, this->va_soft_images[0].height, flags);
+             }
     }
 
     if(vaapi_check_status(this, vaStatus, "vaAssociateSubpicture()")) {
@@ -1704,13 +1901,40 @@
             (overlay->rgb_clut > 0 || overlay->hili_rgb_clut > 0) ? " rgb ": " ycbcr ",
             overlay->width, overlay->height, overlay->x, overlay->y,
             overlay->hili_left, overlay->hili_top,
-            overlay->hili_right, overlay->hili_bottom);
+            overlay->hili_right, overlay->hili_bottom,
+            overlay->video_window_width,overlay->video_window_height,
+            overlay->video_window_x,overlay->video_window_y);
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  {
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(vaapi_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy (this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
   if (overlay->argb_layer && overlay->argb_layer->buffer)
     lprintf("overlay[%d] argb %s %dx%d@%d,%d dirty rect %d,%d-%d,%d\n", i,
             overlay->unscaled ? " unscaled ": " scaled ",
             overlay->width, overlay->height, overlay->x, overlay->y,
             overlay->argb_layer->x1, overlay->argb_layer->y1,
-            overlay->argb_layer->x2, overlay->argb_layer->y2);
+            overlay->argb_layer->x2, overlay->argb_layer->y2,
+            overlay->extent_width, overlay->extent_height,
+            overlay->video_window_width,overlay->video_window_height,
+            overlay->video_window_x,overlay->video_window_y);
 
 
   this->overlays[i] = overlay;
@@ -1843,6 +2067,16 @@
       else
         this->overlay_bitmap_height = UMAX (unscaled_height, this->sc.gui_height);
 
+      if(this->enigma_osd_width)
+        this->overlay_bitmap_width =  UMAX (this->enigma_osd_width, this->sc.gui_width);
+      else
+        this->overlay_bitmap_width =  UMAX (unscaled_width, this->sc.gui_width);
+
+      if(this->enigma_osd_height)
+        this->overlay_bitmap_height = UMAX (this->enigma_osd_height, this->sc.gui_height);
+      else
+        this->overlay_bitmap_height = UMAX (unscaled_height, this->sc.gui_height);
+
     } else if (need_init) {
 
       if(this->vdr_osd_width) 
@@ -1855,6 +2089,15 @@
       else
         this->overlay_bitmap_height = UMAX (output_height, this->sc.gui_height);
 
+      if(this->enigma_osd_width)
+        this->overlay_bitmap_width =  UMAX (this->enigma_osd_width, this->sc.gui_width);
+      else
+        this->overlay_bitmap_width =  UMAX (output_width, this->sc.gui_width);
+
+      if(this->enigma_osd_height)
+        this->overlay_bitmap_height = UMAX (this->enigma_osd_height, this->sc.gui_height);
+      else
+        this->overlay_bitmap_height = UMAX (output_height, this->sc.gui_height);
     }
   }
 
@@ -1986,6 +2229,397 @@
   return ret;
 }
 
+static void vaapi_provide_standard_frame_data (vo_frame_t *this, xine_current_frame_data_t *data)
+{
+  vaapi_driver_t      *driver     = (vaapi_driver_t *) this->driver;
+  ff_vaapi_context_t  *va_context = driver->va_context;
+
+  vaapi_accel_t       *accel      = (vaapi_accel_t *) this->accel_data;
+  ff_vaapi_surface_t  *va_surface;
+
+  uint32_t  pitches[3];
+  uint8_t   *base[3];
+
+  if (this->format != XINE_IMGFMT_VAAPI) {
+    xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_provide_standard_frame_data: unexpected frame format 0x%08x!\n", this->format);
+    return;
+  }
+
+  if (!accel)
+    return;
+
+  va_surface = &va_context->va_render_surfaces[accel->index];
+  if (va_surface->va_surface_id == VA_INVALID_SURFACE)
+    return;
+
+  lprintf("vaapi_provide_standard_frame_data %s 0x%08x width %d height %d\n", 
+      (this->format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((this->format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2"),
+      va_surface->va_surface_id, this->width, this->height);
+
+  pthread_mutex_lock(&driver->vaapi_lock);
+  LOCK_DISPLAY (driver);
+
+  int width = va_context->width;
+  int height = va_context->height;
+
+  data->format = XINE_IMGFMT_YV12;
+  data->img_size = width * height
+                   + ((width + 1) / 2) * ((height + 1) / 2)
+                   + ((width + 1) / 2) * ((height + 1) / 2);
+  if (data->img) {
+    pitches[0] = width;
+    pitches[2] = width / 2;
+    pitches[1] = width / 2;
+    base[0] = data->img;
+    base[2] = data->img + width * height;
+    base[1] = data->img + width * height + width * this->height / 4;
+
+    VAImage   va_image;
+    VAStatus  vaStatus;
+    void      *p_base;
+    int        is_bound;
+
+    vaStatus = vaSyncSurface(va_context->va_display, va_surface->va_surface_id);
+    vaapi_check_status(driver, vaStatus, "vaSyncSurface()");
+
+    VASurfaceStatus surf_status = 0;
+
+    if (driver->va->query_va_status) {
+      vaStatus = vaQuerySurfaceStatus(va_context->va_display, va_surface->va_surface_id, &surf_status);
+      vaapi_check_status(driver, vaStatus, "vaQuerySurfaceStatus()");
+    } else {
+      surf_status = VASurfaceReady;
+    }
+
+    if(surf_status != VASurfaceReady)
+      goto error;
+
+    vaStatus = _x_va_create_image(driver->va, va_surface->va_surface_id, &va_image, width, height, 0, &is_bound);
+    if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()"))
+      goto error;
+
+    lprintf("vaapi_provide_standard_frame_data accel->va_surface_id 0x%08x va_image.image_id 0x%08x va_context->width %d va_context->height %d va_image.width %d va_image.height %d width %d height %d size1 %d size2 %d %d %d %d status %d num_planes %d\n", 
+       va_surface->va_surface_id, va_image.image_id, va_context->width, va_context->height, va_image.width, va_image.height, width, height, va_image.data_size, data->img_size, 
+       va_image.pitches[0], va_image.pitches[1], va_image.pitches[2], surf_status, va_image.num_planes);
+
+    if(va_image.image_id == VA_INVALID_ID)
+      goto error;
+
+    if (!is_bound) {
+      vaStatus = vaGetImage(va_context->va_display, va_surface->va_surface_id, 0, 0,
+                          va_image.width, va_image.height, va_image.image_id);
+    } else {
+      vaStatus = VA_STATUS_SUCCESS;
+    }
+
+    if(vaapi_check_status(driver, vaStatus, "vaGetImage()")) {
+      vaStatus = vaMapBuffer( va_context->va_display, va_image.buf, &p_base ) ;
+      if(vaapi_check_status(driver, vaStatus, "vaMapBuffer()")) {
+
+        /*
+        uint8_t *src[3] = { NULL, };
+        src[0] = (uint8_t *)p_base + va_image.offsets[0];
+        src[1] = (uint8_t *)p_base + va_image.offsets[1];
+        src[2] = (uint8_t *)p_base + va_image.offsets[2];
+        */
+
+        if( va_image.format.fourcc == VA_FOURCC( 'Y', 'V', '1', '2' ) ||
+            va_image.format.fourcc == VA_FOURCC( 'I', '4', '2', '0' ) ) {
+          lprintf("VAAPI YV12 image\n");
+
+          yv12_to_yv12(
+            (uint8_t*)p_base + va_image.offsets[0], va_image.pitches[0],
+            base[0], pitches[0],
+            (uint8_t*)p_base + va_image.offsets[1], va_image.pitches[1],
+            base[1], pitches[1],
+            (uint8_t*)p_base + va_image.offsets[2], va_image.pitches[2],
+            base[2], pitches[2],
+            va_image.width, va_image.height);
+
+        } else if( va_image.format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' ) ) {
+          lprintf("VAAPI NV12 image\n");
+
+          lprintf("va_image.offsets[0] %d va_image.offsets[1] %d va_image.offsets[2] %d size %d size %d size %d width %d height %d width %d height %d\n",
+              va_image.offsets[0], va_image.offsets[1], va_image.offsets[2], va_image.data_size, va_image.width * va_image.height,
+              data->img_size, width, height, va_image.width, va_image.height);
+
+          base[0] = data->img;
+          base[1] = data->img + width * height;
+          base[2] = data->img + width * height + width * height / 4;
+          _x_nv12_to_yv12((uint8_t *)p_base + va_image.offsets[0], va_image.pitches[0],
+                       (uint8_t *)p_base + va_image.offsets[1], va_image.pitches[1],
+                       base[0], pitches[0],
+                       base[1], pitches[1],
+                       base[2], pitches[2],
+                       va_image.width  > width  ? width  : va_image.width,
+                       va_image.height > height ? height : va_image.height);
+
+        } else {
+          printf("vaapi_provide_standard_frame_data unsupported image format\n");
+        }
+
+        vaStatus = vaUnmapBuffer(va_context->va_display, va_image.buf);
+        vaapi_check_status(driver, vaStatus, "vaUnmapBuffer()");
+        _x_va_destroy_image(driver->va, &va_image);
+      }
+    }
+  }
+
+error:
+  UNLOCK_DISPLAY (driver);
+  pthread_mutex_unlock(&driver->vaapi_lock);
+}
+
+static void vaapi_duplicate_frame_data (vo_frame_t *this_gen, vo_frame_t *original)
+{
+  vaapi_driver_t      *driver     = (vaapi_driver_t *) original->driver;
+  ff_vaapi_context_t  *va_context = driver->va_context;
+
+  mem_frame_t *this = xine_container_of(this_gen, mem_frame_t, vo_frame);
+  mem_frame_t *orig = xine_container_of(original, mem_frame_t, vo_frame);
+
+  vaapi_accel_t *accel_this = this_gen->accel_data;
+  vaapi_accel_t *accel_orig = original->accel_data;
+
+  ff_vaapi_surface_t *va_surface_this;
+  ff_vaapi_surface_t *va_surface_orig;
+
+  if (orig->vo_frame.format != XINE_IMGFMT_VAAPI) {
+    xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: unexpected frame format 0x%08x!\n", orig->format);
+    return;
+  }
+
+  if (this->vo_frame.format != XINE_IMGFMT_VAAPI) {
+    xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: unexpected frame format 0x%08x!\n", this->format);
+    return;
+  }
+
+  if (driver->guarded_render) {
+    if (accel_orig->index >= RENDER_SURFACES) {
+      xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: invalid source surface\n");
+      return;
+    }
+    va_surface_orig = &va_context->va_render_surfaces[accel_orig->index];
+
+    va_surface_this = alloc_vaapi_surface(this_gen);
+    if (!va_surface_this) {
+      xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: surface allocation failed\n");
+      return;
+    }
+  } else {
+    _x_assert (accel_this->index < RENDER_SURFACES); /* "fixed" in this mode */
+    _x_assert (accel_orig->index < RENDER_SURFACES); /* "fixed" in this mode */
+    va_surface_this = &va_context->va_render_surfaces[accel_this->index];
+    va_surface_orig = &va_context->va_render_surfaces[accel_orig->index];
+  }
+
+  lprintf("vaapi_duplicate_frame_data  0x%08x <- 0x%08x\n",
+          va_surface_this->va_surface_id, va_surface_orig->va_surface_id);
+
+  pthread_mutex_lock(&driver->vaapi_lock);
+  LOCK_DISPLAY (driver);
+
+  VAImage   va_image_orig;
+  VAImage   va_image_this;
+  VAStatus  vaStatus;
+  void      *p_base_orig = NULL;
+  void      *p_base_this = NULL;
+
+  va_image_this.image_id = VA_INVALID_ID;
+  va_image_orig.image_id = VA_INVALID_ID;
+
+  vaStatus = vaSyncSurface(va_context->va_display, va_surface_orig->va_surface_id);
+  vaapi_check_status(driver, vaStatus, "vaSyncSurface()");
+
+  int this_width = va_context->width;
+  int this_height = va_context->height;
+  int orig_width = va_context->width;
+  int orig_height = va_context->height;
+  int this_is_bound, orig_is_bound;
+
+  vaStatus = _x_va_create_image(driver->va, va_surface_orig->va_surface_id, &va_image_orig, orig_width, orig_height, 0, &orig_is_bound);
+  if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()")) {
+    va_image_orig.image_id = VA_INVALID_ID;
+    goto error;
+  }
+
+  vaStatus = _x_va_create_image(driver->va, va_surface_this->va_surface_id, &va_image_this, this_width, this_height, 0, &this_is_bound);
+  if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()")) {
+    va_image_this.image_id = VA_INVALID_ID;
+    goto error;
+  }
+
+  if(va_image_orig.image_id == VA_INVALID_ID || va_image_this.image_id == VA_INVALID_ID) {
+    printf("vaapi_duplicate_frame_data invalid image\n");
+    goto error;
+  }
+
+  lprintf("vaapi_duplicate_frame_data va_image_orig.image_id 0x%08x va_image_orig.width %d va_image_orig.height %d width %d height %d size %d %d %d %d\n",
+       va_image_orig.image_id, va_image_orig.width, va_image_orig.height, this->width, this->height, va_image_orig.data_size, 
+       va_image_orig.pitches[0], va_image_orig.pitches[1], va_image_orig.pitches[2]);
+
+  if (!orig_is_bound) {
+    vaStatus = vaGetImage(va_context->va_display, va_surface_orig->va_surface_id, 0, 0,
+                          va_image_orig.width, va_image_orig.height, va_image_orig.image_id);
+  } else {
+    vaStatus = VA_STATUS_SUCCESS;
+  }
+
+  if(vaapi_check_status(driver, vaStatus, "vaGetImage()")) {
+
+    if (!this_is_bound) {
+      vaStatus = vaPutImage(va_context->va_display, va_surface_this->va_surface_id, va_image_orig.image_id,
+                            0, 0, va_image_orig.width, va_image_orig.height,
+                            0, 0, va_image_this.width, va_image_this.height);
+      vaapi_check_status(driver, vaStatus, "vaPutImage()");
+    } else {
+      vaStatus = vaMapBuffer( va_context->va_display, va_image_orig.buf, &p_base_orig ) ;
+      if(!vaapi_check_status(driver, vaStatus, "vaMapBuffer()"))
+        goto error;
+
+      vaStatus = vaMapBuffer( va_context->va_display, va_image_this.buf, &p_base_this ) ;
+      if(!vaapi_check_status(driver, vaStatus, "vaMapBuffer()"))
+        goto error;
+
+      int size = (va_image_orig.data_size > va_image_this.data_size) ? va_image_this.data_size : va_image_orig.data_size;
+      xine_fast_memcpy((uint8_t *) p_base_this, (uint8_t *) p_base_orig, size);
+
+    }
+  }
+
+  if (driver->guarded_render) {
+    accel_this->index = va_surface_this->index;
+    va_surface_this->status = SURFACE_RENDER_RELEASE;
+  }
+
+error:
+  if(p_base_orig) {
+    vaStatus = vaUnmapBuffer(va_context->va_display, va_image_orig.buf);
+    vaapi_check_status(driver, vaStatus, "vaUnmapBuffer()");
+  }
+  if(p_base_this) {
+    vaStatus = vaUnmapBuffer(va_context->va_display, va_image_this.buf);
+    vaapi_check_status(driver, vaStatus, "vaUnmapBuffer()");
+  }
+
+  _x_va_destroy_image(driver->va, &va_image_orig);
+  _x_va_destroy_image(driver->va, &va_image_this);
+
+  UNLOCK_DISPLAY (driver);
+  pthread_mutex_unlock(&driver->vaapi_lock);
+}
+
+static void vaapi_update_frame_format (vo_driver_t *this_gen,
+                                       vo_frame_t *frame_gen,
+                                       uint32_t width, uint32_t height,
+                                       double ratio, int format, int flags) {
+  vaapi_driver_t      *this       = (vaapi_driver_t *) this_gen;
+  mem_frame_t         *frame      = xine_container_of(frame_gen, mem_frame_t, vo_frame);
+
+  if (this->guarded_render && frame->format == XINE_IMGFMT_VAAPI) {
+    /*
+     * This code handles frames that were dropped (used in decoder, but not drawn).
+     * -> we need to lock because of surface may still be in use in decoder.
+     */
+    vaapi_accel_t      *accel      = frame_gen->accel_data;
+    if (accel->index < RENDER_SURFACES) {
+      ff_vaapi_surface_t *va_surface = &this->va_context->va_render_surfaces[accel->index];
+      _x_va_surface_displayed(this->va, va_surface);
+    }
+  }
+
+  lprintf("vaapi_update_frame_format %s %s width %d height %d\n",
+        (frame->format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((frame->format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2") ,
+        (format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2") ,
+        width, height);
+
+  if ((frame->width ^ width) | (frame->height ^ height) | (frame->format ^ format)) {
+
+    mem_frame_update_frame_format(this_gen, frame_gen, width, height, ratio, format, flags);
+
+    if (format == XINE_IMGFMT_VAAPI) {
+      frame->width = width; /* mem_frame freed frame->base */
+      frame->vo_frame.width = width;
+      frame->vo_frame.proc_duplicate_frame_data = vaapi_duplicate_frame_data;
+      frame->vo_frame.proc_provide_standard_frame_data = vaapi_provide_standard_frame_data;
+      lprintf("XINE_IMGFMT_VAAPI width %d height %d\n", width, height);
+    } else {
+      frame->vo_frame.proc_duplicate_frame_data = NULL;
+      frame->vo_frame.proc_provide_standard_frame_data = NULL;
+    }
+  }
+}
+
+static void yv12_to_nv12(const uint8_t *y_src, int y_src_pitch,
+                         const uint8_t *u_src, int u_src_pitch,
+                         const uint8_t *v_src, int v_src_pitch,
+                         uint8_t *y_dst,  int y_dst_pitch,
+                         uint8_t *uv_dst, int uv_dst_pitch,
+                         int width, int height) {
+  int y, x;
+
+  lprintf("yv12_to_nv12 converter\n");
+
+  for (y = 0; y < height; y++) {
+    xine_fast_memcpy(y_dst, y_src, width);
+    y_src += y_src_pitch;
+    y_dst += y_dst_pitch;
+  }
+
+  /* Combine uv line to temporary (cached) buffer.
+     Avoids fetching destination plane to cache. */
+  uint8_t *line = xine_malloc_aligned(width + 1);
+  if (!line)
+    return;
+
+  for(y = 0; y < height / 2; y++) {
+    for(x = 0; x < width / 2; x++) {
+      line[2*x]     = *(u_src + x);
+      line[2*x + 1] = *(v_src + x);
+    }
+
+    xine_fast_memcpy(uv_dst, line, width);
+
+    uv_dst += uv_dst_pitch;
+    u_src += u_src_pitch;
+    v_src += v_src_pitch;
+  }
+
+  xine_free_aligned(line);
+}
+
+static void yuy2_to_nv12(const uint8_t *src_yuy2_map, int yuy2_pitch,
+                         uint8_t *y_dst,  int y_dst_pitch,
+                         uint8_t *uv_dst, int uv_dst_pitch,
+                         int width, int height) {
+  int y, x;
+
+  const uint8_t *yuy2_map = src_yuy2_map;
+  for(y = 0; y < height; y++) {
+    uint8_t *y_dst_tmp = y_dst;
+    const uint8_t *yuy2_src_tmp = yuy2_map;
+    for(x = 0; x < width / 2; x++) {
+      *(y_dst_tmp++   ) = *(yuy2_src_tmp++);
+      yuy2_src_tmp++;
+      *(y_dst_tmp++   ) = *(yuy2_src_tmp++);
+      yuy2_src_tmp++;
+    }
+    y_dst += y_dst_pitch;
+    yuy2_map += yuy2_pitch;
+  }
+
+  yuy2_map = src_yuy2_map;
+  for(y = 0; y < height; y += 2) {
+    for(x = 0; x < width; x += 2) {
+      *(uv_dst + x )     = *(yuy2_map + x*2 + 1);
+      *(uv_dst + x + 1 ) = *(yuy2_map + x*2 + 3);
+    }
+    uv_dst += uv_dst_pitch;
+    yuy2_map += yuy2_pitch * 2;
+  }
+
+}
+
 static VAStatus vaapi_software_render_frame(vaapi_driver_t *this, mem_frame_t *frame,
                                             VAImage *va_image, int is_bound, VASurfaceID va_surface_id) {
   ff_vaapi_context_t *va_context      = this->va_context;
@@ -2044,7 +2678,7 @@
     } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' )) {
       lprintf("vaapi_software_render_frame yv12 -> nv12 convert\n");
 
-      _x_yv12_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
+      yv12_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
                       frame->vo_frame.base[1], frame->vo_frame.pitches[1],
                       frame->vo_frame.base[2], frame->vo_frame.pitches[2],
                       (uint8_t *)p_base + va_image->offsets[0], va_image->pitches[0],
@@ -2067,7 +2701,7 @@
     } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' )) {
       lprintf("vaapi_software_render_frame yuy2 -> nv12 convert\n");
 
-      _x_yuy2_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
+      yuy2_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
                       (uint8_t *)p_base + va_image->offsets[0], va_image->pitches[0],
                       (uint8_t *)p_base + va_image->offsets[1], va_image->pitches[1],
                       frame->vo_frame.width, frame->vo_frame.height);
@@ -2080,9 +2714,16 @@
     return vaStatus;
 
   if (!is_bound) {
+    if(this->video_window_width && this->video_window_height) // video is displayed in a small window
+    {
+    vaStatus = vaPutImage(va_context->va_display, va_surface_id, va_image->image_id,
+                        0, 0, this->video_window_x, this->video_window_y,
+                        0, 0, this->video_window_width, this->video_window_height);
+    } else {
     vaStatus = vaPutImage(va_context->va_display, va_surface_id, va_image->image_id,
                         0, 0, va_image->width, va_image->height,
                         0, 0, va_image->width, va_image->height);
+           }
     if(!vaapi_check_status(this, vaStatus, "vaPutImage()"))
       return vaStatus;
   }
@@ -2160,12 +2801,22 @@
 #endif
     {
 
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
+      vaStatus = vaPutSurface(va_context->va_display, va_surface_id, this->window,
+                   this->sc.displayed_xoffset, this->sc.displayed_yoffset,
+                   this->sc.displayed_width, this->sc.displayed_height,
+                   this->video_window_x, this->video_window_y,
+                   this->video_window_width, this->video_window_height,
+                   NULL, 0, flags);
+      } else {
       vaStatus = vaPutSurface(va_context->va_display, va_surface_id, this->window,
                    this->sc.displayed_xoffset, this->sc.displayed_yoffset,
                    this->sc.displayed_width, this->sc.displayed_height,
                    this->sc.output_xoffset, this->sc.output_yoffset,
                    this->sc.output_width, this->sc.output_height,
                    NULL, 0, flags);
+             }
       if(!vaapi_check_status(this, vaStatus, "vaPutSurface()"))
         return vaStatus;
     }
@@ -2187,13 +2838,23 @@
 }
 */
 
+static void _x_va_frame_displayed(vaapi_context_impl_t *va_context, vo_frame_t *vo_frame)
+{
+  vaapi_accel_t *accel = vo_frame->accel_data;
+
+  if (accel->index < RENDER_SURFACES) {
+    ff_vaapi_surface_t *va_surface = &va_context->c.va_render_surfaces[accel->index];
+    _x_va_surface_displayed(va_context, va_surface);
+  }
+}
+
 static void _add_recent_frame (vaapi_driver_t *this, vo_frame_t *vo_frame) {
   int i;
 
   i = VO_NUM_RECENT_FRAMES-1;
   if (this->recent_frames[i]) {
-    if (this->guarded_render && this->recent_frames[i]->format == XINE_IMGFMT_VAAPI)
-      _x_va_frame_displayed(this->recent_frames[i]);
+    if (this->guarded_render && vo_frame->format == XINE_IMGFMT_VAAPI)
+      _x_va_frame_displayed(this->va, this->recent_frames[i]);
     this->recent_frames[i]->free (this->recent_frames[i]);
   }
 
@@ -2644,6 +3305,10 @@
 
   UNLOCK_DISPLAY (this);
 
+  _x_freep (&this->va_subpic_formats);
+  _x_freep (&this->va_subpic_flags);
+  this->va_num_subpic_formats = 0;
+
   pthread_mutex_unlock(&this->vaapi_lock);
   pthread_mutex_destroy(&this->vaapi_lock);
 
@@ -2674,6 +3339,20 @@
   this->vdr_osd_height = entry->num_value < 0 ? 0 : entry->num_value;
 }
 
+static void vaapi_enigma_osd_width_flag( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
+
+  this->enigma_osd_width = entry->num_value < 0 ? 0 : entry->num_value;
+}
+
+static void vaapi_enigma_osd_height_flag( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
+
+  this->enigma_osd_height = entry->num_value < 0 ? 0 : entry->num_value;
+}
+
 static void vaapi_deinterlace_flag( void *this_gen, xine_cfg_entry_t *entry )
 {
   vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
@@ -2778,14 +3457,14 @@
 static int vaapi_initialize(vaapi_driver_t *this, int visual_type, const void *visual)
 {
   VAStatus vaStatus;
-  unsigned interop_flags = XINE_VA_DISPLAY_X11;
+  int fmt_count = 0;
 
 #ifdef ENABLE_VA_GLX
-  if (this->opengl_render)
-    interop_flags = XINE_VA_DISPLAY_GLX;
+  this->va = _x_va_new(this->xine, visual_type, visual, this->opengl_render);
+#else
+  this->va = _x_va_new(this->xine, visual_type, visual, 0);
 #endif
 
-  this->va = _x_va_new(this->xine, visual_type, visual, interop_flags);
   if (!this->va)
     return 0;
 
@@ -2813,61 +3492,17 @@
   vaapi_set_background_color(this);
   vaapi_display_attribs(this);
 
-  if (this->overlay_mode == 1) {
-    VAImageFormat *va_subpic_formats = NULL;
-    unsigned int *va_subpic_flags = NULL;
-    int fmt_count = vaMaxNumSubpictureFormats (this->va_context->va_display);
-
-    if ((unsigned int)(fmt_count - 1) < 256) {
-      va_subpic_formats = calloc (fmt_count, sizeof (*va_subpic_formats));
-      va_subpic_flags = calloc (fmt_count, sizeof (*va_subpic_flags));
-      /* FIXME: the mesa radeonsi driver has a severe overlay bug.
-       * for vdpau, we got a usable workaround (see video_out_vdpau.c).
-       * for vaapi, glx mode should be 1 2.
-       * in any case, treat missing overlays as non fatal. */
-      vaStatus = vaQuerySubpictureFormats (this->va_context->va_display,
-        va_subpic_formats, va_subpic_flags, &fmt_count);
-      if (!vaapi_check_status (this, vaStatus, "vaQuerySubpictureFormats()"))
-        fmt_count = 0;
-    }
-
-    if ((unsigned int)(fmt_count - 1) < 256) {
-      char buf[256 * 22], *q = buf;
-      int i;
-      for (i = 0; i < fmt_count; i++) {
-        *q++ = ' ';
-        q += _x_tag32_me2str (q, va_subpic_formats[i].fourcc);
-        if (va_subpic_formats[i].fourcc == VA_FOURCC ('B', 'G', 'R', 'A')) {
-          this->bgra_subpic_format = va_subpic_formats[i];
-          this->bgra_subpic_flags = va_subpic_flags[i];
-        }
-      }
-      *q = 0;
-      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: subpicture formats: %s.\n", buf);
-    } else {
-      /* this->overlay_mode = 0;
-       * this->xine->config->update_num (this->xine->config, "video.output.vaapi_overlay_mode", 0); */
-      xprintf (this->xine, XINE_VERBOSITY_LOG,
-        LOG_MODULE " vaapi_open: bogus subpicture format count %d, overlays disabled.\n", fmt_count);
-    }
-
-    free (va_subpic_flags);
-    free (va_subpic_formats);
-  } else if (this->overlay_mode == 2) {
-    /* DEBUG only. */
-    this->bgra_subpic_format.fourcc = VA_FOURCC ('B', 'G', 'R', 'A');
-    this->bgra_subpic_format.byte_order = 1;
-    this->bgra_subpic_format.bits_per_pixel = 32;
-    this->bgra_subpic_format.depth = 32;
-    this->bgra_subpic_format.red_mask = 0x00ff0000;
-    this->bgra_subpic_format.green_mask = 0x0000ff00;
-    this->bgra_subpic_format.blue_mask = 0x000000ff;
-    this->bgra_subpic_format.alpha_mask = 0xff000000;
-    this->bgra_subpic_flags = 0;
-    xprintf (this->xine, XINE_VERBOSITY_LOG,
-      LOG_MODULE " vaapi_open: warning: forcing BGRA overlays, this may crash.\n");
+  fmt_count = vaMaxNumSubpictureFormats (this->va_context->va_display);
+  if (fmt_count > 0) {
+    this->va_subpic_formats = calloc (fmt_count, sizeof (*this->va_subpic_formats));
+    this->va_subpic_flags   = calloc (fmt_count, sizeof (*this->va_subpic_flags));
+
+    vaStatus = vaQuerySubpictureFormats (this->va_context->va_display,
+      this->va_subpic_formats, this->va_subpic_flags, &this->va_num_subpic_formats);
+    if (!vaapi_check_status (this, vaStatus, "vaQuerySubpictureFormats()"))
+      return 0;
   } else {
-    xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: overlays disabled manually.\n");
+    this->va_num_subpic_formats = 0;
   }
 
   if(vaapi_init_internal(this, SW_CONTEXT_INIT_FORMAT, SW_WIDTH, SW_HEIGHT) != VA_STATUS_SUCCESS)
@@ -2892,6 +3527,16 @@
 
   pthread_mutex_init(&this->vaapi_lock, NULL);
   pthread_mutex_lock(&this->vaapi_lock);
+  
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
 
   this->xine                    = class->xine;
 
@@ -2941,6 +3586,7 @@
   this->gl_texture                      = GL_NONE;
 #endif /* ENABLE_VA_GLX */
 
+  this->num_frame_buffers               = 0;
   this->va_soft_surface_ids             = this->va_soft_surface_ids_storage;
   this->va_soft_images                  = this->va_soft_images_storage;
   for (i = 0; i < SOFT_SURFACES; i++) {
@@ -2961,7 +3607,7 @@
 
   this->vo_driver.get_capabilities     = vaapi_get_capabilities;
   this->vo_driver.alloc_frame          = vaapi_alloc_frame;
-  this->vo_driver.update_frame_format  = _x_va_frame_update_frame_format;
+  this->vo_driver.update_frame_format  = vaapi_update_frame_format;
   this->vo_driver.overlay_begin        = vaapi_overlay_begin;
   this->vo_driver.overlay_blend        = vaapi_overlay_blend;
   this->vo_driver.overlay_end          = vaapi_overlay_end;
@@ -2976,6 +3622,8 @@
   this->deinterlace                    = 0;
   this->vdr_osd_width                  = 0;
   this->vdr_osd_height                 = 0;
+  this->enigma_osd_width               = 0;
+  this->enigma_osd_height              = 0;
 
   i = config->register_num( config, "video.output.vaapi_vdr_osd_width", 0,
         _("vaapi: VDR osd width workaround."),
@@ -2989,6 +3637,18 @@
         10, vaapi_vdr_osd_height_flag, this );
   this->vdr_osd_height = i < 0 ? 0 : i;
 
+  i = config->register_num( config, "video.output.vaapi_enigma_osd_width", 0,
+        _("vaapi: ENIGMA osd width workaround."),
+        _("vaapi: ENIGMA osd width workaround."),
+        10, vaapi_enigma_osd_width_flag, this );
+  this->enigma_osd_width = i < 0 ? 0 : i;
+
+  i = config->register_num( config, "video.output.vaapi_enigma_osd_height", 0,
+        _("vaapi: ENIGMA osd height workaround."),
+        _("vaapi: ENIGMA osd height workaround."),
+        10, vaapi_enigma_osd_height_flag, this );
+  this->enigma_osd_height = i < 0 ? 0 : i;
+
   this->deinterlace = config->register_num( config, "video.output.vaapi_deinterlace", 0,
         _("vaapi: set deinterlace to 0 ( none ), 1 ( top field ), 2 ( bob )."),
         _("vaapi: set deinterlace to 0 ( none ), 1 ( top field ), 2 ( bob )."),
@@ -3046,15 +3706,6 @@
     vaapi_csc_mode, this);
   vaapi_set_csc_mode (this, this->csc_mode);
 
-  this->overlay_mode = this->xine->config->register_range (this->xine->config,
-    "video.output.vaapi_overlay_mode", 1, 0, 2,
-    _("VAAPI overlay mode"),
-    _("How to display onscreen messages and subtitles:\n"
-      "0: Disable overlays for broken driver (eg Mesa radeonsi),\n"
-      "1: Auto.\n"
-      "2: Force BGRA.\n"),
-    10, NULL, NULL);
-
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Deinterlace : %d\n", this->deinterlace);
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Render surfaces : %d\n", RENDER_SURFACES);
 #ifdef ENABLE_VA_GLX
@@ -3108,3 +3759,4 @@
   { PLUGIN_VIDEO_OUT, 22, "vaapi", XINE_VERSION_CODE, &vo_info_vaapi, vaapi_init_class },
   { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
 };
+
diff -ruN o/src/video_out/video_out_vdpau.c pc/src/video_out/video_out_vdpau.c
--- o/src/video_out/video_out_vdpau.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/video_out/video_out_vdpau.c	2024-07-21 14:42:55.843005424 +0300
@@ -1051,7 +1051,14 @@
       this->ovl_video_dest_rect = vid_rect;
     }
 
-    if (!ovl->unscaled) {
+    if (ovl->unscaled==2) {
+      ovl_rect.x0 = 0;
+      ovl_rect.y0 = 0;
+      ovl_rect.x1 = this->sc.gui_width;
+      ovl_rect.y1 = this->sc.gui_height;
+      this->ovl_changed = 1;
+    }
+    else if (ovl->unscaled==0) {
       double rx, ry;
 
       if (zoom) {
@@ -2580,6 +2587,12 @@
       this->deinterlace = value;
       this->prop_changed |= _VOVDP_S_DEINT;
       break;
+    case VO_PROP_DEINTERLACE_SD:
+      this->deinterlace_method_sd = value;
+      break;
+    case VO_PROP_DEINTERLACE_HD:
+      this->deinterlace_method_hd = value;
+      break;
     case VO_PROP_ZOOM_X:
       if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
         this->zoom_x = value;
diff -ruN o/src/xine-engine/metronom.c pc/src/xine-engine/metronom.c
--- o/src/xine-engine/metronom.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/xine-engine/metronom.c	2024-07-21 14:42:55.844005408 +0300
@@ -451,6 +451,7 @@
     int           seek;
     int           force_jump;
     int           vdr_hack;
+    int           enigma_hack;
   } audio;
 
   /* video */
@@ -523,6 +524,22 @@
   }
 }
 
+static void metronom_enigma_hack_disc (metronom_impl_t *this, int64_t pts_offs) {
+  if (pts_offs == 0) {
+    this->audio.enigma_hack = 0;
+  } else {
+    this->audio.seek = (this->audio.enigma_hack == 2);
+  }
+}
+
+static void metronom_enigma_hack_prebuffer (metronom_impl_t *this, int64_t pts) {
+  if (pts == 2000) {
+    this->audio.enigma_hack = (this->audio.enigma_hack == 0) ? 1 : 0;
+  } else if (pts == 14400) {
+    this->audio.enigma_hack = (this->audio.enigma_hack == 1) || (this->audio.enigma_hack == 2) ? 2 : 0;
+  }
+}
+
 static void metronom_set_audio_rate (metronom_t *this_gen, int64_t pts_per_smpls) {
   metronom_impl_t *this = (metronom_impl_t *)this_gen;
 
@@ -662,6 +679,7 @@
       this->video.last_pts   = 0;
       this->audio.last_pts   = 0;
       metronom_vdr_hack_disc (this, disc_off);
+      metronom_enigma_hack_disc (this, disc_off);
       xprintf (this->xine, XINE_VERBOSITY_DEBUG,
         "metronom: vpts adjusted with prebuffer to %" PRId64 ".\n", this->video.vpts);
       lprintf("video.vpts: %" PRId64 ", audio.vpts: %" PRId64 "\n", this->video.vpts, this->audio.vpts);
@@ -815,6 +833,37 @@
     "metronom: vdr trick pts %" PRId64 ", vpts %" PRId64 ".\n", pts, this->video.vpts);
 }
 
+static void metronom_handle_enigma_trick_pts (metronom_impl_t *this, int64_t pts) {
+  int64_t cur_time = this->xine->clock->get_current_time (this->xine->clock);
+  if (this->video.vpts < cur_time) {
+    if (this->audio.vpts >= cur_time) {
+      /* still frame with audio */
+      this->video.vpts = this->audio.vpts;
+    } else {
+      /* still frame, no audio */
+      this->audio.vpts =
+      this->video.vpts = this->prebuffer + cur_time;
+      this->audio.vpts_rmndr = 0;
+      this->video.force_jump = 1;
+      this->audio.force_jump = 1;
+      this->video.drift = 0;
+    }
+  } else {
+    if (this->audio.vpts < cur_time) {
+      /* video, no sound */
+      this->audio.vpts = this->video.vpts;
+      this->audio.vpts_rmndr = 0;
+    }
+  }
+  this->vpts_offset = this->video.vpts - pts;
+  this->bounce.diff = this->bounce.vpts_offs - this->vpts_offset;
+  this->bounce.left_audio = -1;
+  this->bounce.left_video = -1;
+  this->bounce.jumped = 0;
+  xprintf (this->xine, XINE_VERBOSITY_DEBUG,
+    "metronom: enigma trick pts %" PRId64 ", vpts %" PRId64 ".\n", pts, this->video.vpts);
+}
+
 static void metronom_handle_video_discontinuity (metronom_t *this_gen, int type,
                                                  int64_t disc_off) {
   metronom_impl_t *this = (metronom_impl_t *)this_gen;
@@ -1311,12 +1360,17 @@
   case METRONOM_PREBUFFER:
     this->prebuffer = value;
     metronom_vdr_hack_prebuffer (this, value);
+    metronom_enigma_hack_prebuffer (this, value);
     xprintf (this->xine, XINE_VERBOSITY_LOG,
       "metronom: prebuffer=%" PRId64 " pts.\n", this->prebuffer);
     break;
   case METRONOM_VDR_TRICK_PTS:
     metronom_handle_vdr_trick_pts (this, value);
     break;
+  case METRONOM_ENIGMA_TRICK_PTS:
+    metronom_handle_enigma_trick_pts (this, value);
+    break;
+
   default:
     xprintf(this->xine, XINE_VERBOSITY_NONE,
       "metronom: unknown option in set_option: %d.\n", option);
@@ -1392,6 +1446,9 @@
   case METRONOM_VDR_TRICK_PTS:
     result = this->video.vpts;
     break;
+  case METRONOM_ENIGMA_TRICK_PTS:
+    result = this->video.vpts;
+    break;
   default:
     result = 0;
     xprintf (this->xine, XINE_VERBOSITY_NONE,
@@ -1646,6 +1703,7 @@
   this->audio.last_pts         = 0;
   this->audio.vpts_rmndr       = 0;
   this->audio.vdr_hack         = 0;
+  this->audio.enigma_hack      = 0;
   this->audio.seek             = 0;
   this->audio.samples          = 0;
   this->audio.drift_step       = 0;
diff -ruN o/src/xine-engine/osd.c pc/src/xine-engine/osd.c
--- o/src/xine-engine/osd.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/xine-engine/osd.c	2024-07-21 14:42:55.844005408 +0300
@@ -536,6 +536,10 @@
   return _osd_show(osd, vpts, 1);
 }
 
+static int osd_show_gui_scaled (osd_object_t *osd, int64_t vpts) {
+  return _osd_show(osd, vpts, 2);
+}
+
 /*
  * send event to hide osd at given pts (0=now)
  * the object is not changed. there may be subsequent drawing  on it.
@@ -2222,6 +2226,7 @@
   this->r.draw_bitmap        = osd_draw_bitmap;
   this->r.set_argb_buffer    = osd_set_argb_buffer;
   this->r.show_unscaled      = osd_show_unscaled;
+  this->r.show_scaled        = osd_show_gui_scaled;
   this->r.get_capabilities   = osd_get_capabilities;
   this->r.set_extent         = osd_set_extent;
   this->r.set_video_window   = osd_set_video_window;
diff -ruN o/src/xine-engine/video_out.c pc/src/xine-engine/video_out.c
--- o/src/xine-engine/video_out.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/xine-engine/video_out.c	2024-07-21 14:42:55.844005408 +0300
@@ -213,6 +213,7 @@
 
   /* pts value when decoder delivered last video frame */
   int64_t                   last_delivery_pts;
+  int64_t                   last_pts;
 
   video_overlay_manager_t  *overlay_source;
 
@@ -223,6 +224,7 @@
   int                       current_width, current_height;
   int64_t                   current_duration;
 
+  int                       framerate;
   int                       frame_drop_limit_max;
   int                       frame_drop_limit;
   int                       frame_drop_cpt;
@@ -1534,6 +1536,21 @@
       }
     }
     img->stream = &stream->s;
+    int new_framerate = img->duration==0?0:90000*1000/img->duration;
+    if (this->framerate != new_framerate) {
+      this->framerate = new_framerate;
+      xine_event_t event;
+      xine_framerate_data_t data;
+      event.type = XINE_EVENT_FRAMERATE_CHANGE;
+      event.stream = stream;
+      event.data = &data;
+      event.data_length = sizeof(data);
+      data.framerate = this->framerate;
+      xine_event_send( stream, &event );
+    }
+
+    if (img->pts!=0)
+      this->last_pts = img->pts;
     vo_set_img_ei (this, img);
     stream->s.metronom->got_video_frame (stream->s.metronom, img);
 #ifdef ADD_KEYFRAME_INDEX
@@ -2528,6 +2545,7 @@
           if (img) {
             vo_reref (this, img);
             img->vpts = vpts;
+            img->duration = DEFAULT_FRAME_DURATION;
             overlay_and_display_frame (this, img, vpts);
           }
         } else {
@@ -2826,6 +2844,10 @@
     xine_rwlock_unlock (&this->streams_lock);
     break;
 
+  case VO_PROP_LAST_PTS:
+    ret = (intptr_t)&this->last_pts;
+    break;
+
   /*
    * handle XINE_PARAM_xxx properties (convert from driver's range)
    */
diff -ruN o/src/xine-engine/xine_interface.c pc/src/xine-engine/xine_interface.c
--- o/src/xine-engine/xine_interface.c	2023-07-10 19:46:14.000000000 +0300
+++ pc/src/xine-engine/xine_interface.c	2024-07-21 14:42:55.845005392 +0300
@@ -1088,6 +1088,10 @@
   this->osd.renderer->show_unscaled(&this->osd, vpts);
 }
 
+void xine_osd_show_scaled(xine_osd_t *this, int64_t vpts) {
+  this->osd.renderer->show_scaled(&this->osd, vpts);
+}
+
 void xine_osd_hide(xine_osd_t *this, int64_t vpts) {
   this->osd.renderer->hide(&this->osd, vpts);
 }
